---
description: 此规则为开发和维护 Kubernetes 应用程序和基础设施提供全面的最佳实践，涵盖编码标准、安全、性能、测试和部署。
globs: "*.go,*.yaml,*.yml,*.sh,*.tf,*.tfvars,*.json"
---
# Kubernetes 开发和运维最佳实践

本文档概述了在 Kubernetes 生态系统中编写代码和管理基础设施的指南、风格建议和技巧集合。它强调清晰性、可维护性、安全性和性能。

## 1. 代码组织和结构

### 1.1 目录结构

- **根级别：**
  - `cmd/`：主应用程序入口点。每个子目录代表一个单独的命令行工具或服务。
  - `pkg/`：可被其他项目导入的可重用库和组件。
  - `internal/`：不应被外部项目导入的私有代码。强制封装。
  - `api/`：API 定义，包括 protobuf 文件和 OpenAPI 规范。
  - `config/`：配置文件，如 YAML 清单、Kustomize 配置和 Helm 图表。
  - `scripts/`：用于构建、测试和部署应用程序的实用脚本。
  - `docs/`：项目文档。
  - `examples/`：库或应用程序的使用示例。
  - `vendor/`：（如果使用不带外部依赖管理的 `go modules`）包含供应商依赖项。在现代 Go 中通常不推荐使用 `go modules`。
- **组件特定目录：** 在 `pkg/` 或 `internal/` 内，按组件或模块组织代码。每个组件应有自己的目录，明确分离关注点。

示例：

```
my-kubernetes-project/
├── cmd/
│   └── controller/
│       └── main.go
├── pkg/
│   └── api/
│       ├── types.go
│   └── controller/
│       ├── controller.go
│       ├── reconciler.go
│   └── util/
│       └── util.go
├── internal/
│   └── admission/
│       └── webhook.go
├── config/
│   ├── deploy/
│   │   └── deployment.yaml
│   └── kustomize/
│       ├── base/
│       │   ├── kustomization.yaml
│       │   └── ...
│       └── overlays/
│           ├── dev/
│           │   ├── kustomization.yaml
│           │   └── ...
│           └── prod/
│               ├── kustomization.yaml
│               └── ...
├── scripts/
│   └── build.sh
├── docs/
│   └── architecture.md
└── go.mod
```

### 1.2 文件命名约定

- **Go 文件：** 使用小写和下划线（例如，`my_controller.go`）。
- **YAML 文件：** 使用小写和破折号（例如，`deployment.yaml`）。
- **配置文件：** 具有描述性和一致性（例如，`config.yaml`、`kustomization.yaml`）。
- **测试文件：** 遵循标准 Go 约定：`*_test.go`（例如，`my_controller_test.go`）。

### 1.3 模块组织（Go）

- **包：** 将代码组织成代表功能逻辑单元的有意义包。
- **内部包：** 使用 `internal/` 目录创建仅在项目内可见的包。
- **接口：** 定义接口以抽象依赖关系并促进可测试性。

### 1.4 组件架构

- **微服务：** 将应用程序设计为松散耦合的微服务集合。
- **关注点分离：** 每个组件应有单一职责和明确定义的接口。
- **API 网关：** 使用 API 网关处理外部请求的路由、身份验证和速率限制。
- **服务网格：** 考虑使用服务网格（例如，Istio、Linkerd）管理服务间通信、可观察性和安全性。

### 1.5 代码分割策略

- **基于功能的分割：** 按功能或功能性分组代码。
- **基于层的分割：** 将代码分为层，如数据访问、业务逻辑和表示层。
- **基于组件的分割：** 将代码分为可在多个项目间共享的可重用组件。

## 2. 常见模式和反模式

### 2.1 设计模式

- **控制器模式：** 实施控制器以协调 Kubernetes 资源的期望状态与实际状态。
- **操作器模式：** 使用自定义资源和控制器扩展 Kubernetes API，自动化复杂的应用程序管理任务。
- **边车模式：** 在主应用程序容器旁部署边车容器，提供支持功能，如日志记录、监控或安全。
- **大使模式：** 使用大使容器代理到主应用程序容器的网络流量，提供负载均衡、路由和身份验证等功能。
- **适配器模式：** 将请求从一个接口转换为另一个接口，允许不同组件协同工作。
- **单例模式：** 为管理全局资源（如数据库连接或配置设置）实施单例模式。要极其谨慎，因为这可能损害可测试性并引入隐式依赖关系。

### 2.2 常见任务的推荐方法

- **资源管理：** 使用 Kubernetes 资源请求和限制确保应用程序有足够资源并防止资源争用。
- **配置管理：** 使用 ConfigMaps 和 Secrets 将配置数据和敏感信息与应用程序代码分开管理。
- **服务发现：** 使用 Kubernetes 服务为访问应用程序提供稳定端点，即使在 Pod 扩缩容时也是如此。
- **健康检查：** 实施存活性和就绪性探针监控应用程序健康状况并自动重启不健康的 Pod。
- **日志记录和监控：** 使用集中式日志记录和监控系统收集和分析应用程序日志和指标。
- **滚动更新：** 使用 Kubernetes 部署执行零停机时间的应用程序滚动更新。

### 2.3 反模式和代码异味

- **裸 Pod：** 避免直接创建 Pod 而不使用部署或副本集，因为如果节点故障，它们不会自动重新调度。
- **硬编码配置：** 避免在应用程序代码中硬编码配置数据。使用 ConfigMaps 和 Secrets 代替。
- **忽略资源限制：** 未能设置资源请求和限制可能导致资源争用和性能问题。
- **过大的容器：** 保持容器镜像小而专注，以改善启动时间并减少安全风险。
- **特权容器：** 避免在特权模式下运行容器，因为这可能产生安全漏洞。
- **长期分支：** 避免创建长期分支，优先小而频繁地合并到主分支。
- **上帝类：** 避免创建过大和复杂的类。将它们分解为更小、更易管理的类。
- **散弹手术：** 避免在修改单个功能时对多个类进行更改。这表明类设计和耦合不良。
- **功能嫉妒：** 避免访问另一个对象的数据多于自己数据的方法。这表明方法可能在错误的类中。

### 2.4 状态管理最佳实践

- **无状态应用程序：** 尽可能优先使用无状态应用程序，因为它们更容易扩展和管理。
- **持久卷：** 使用持久卷为有状态应用程序存储持久数据。
- **外部数据库：** 考虑使用外部数据库管理应用程序状态，如云提供商托管的数据库。
- **Kubernetes 操作器：** 实施 Kubernetes 操作器自动化有状态应用程序的管理。
- **Etcd：** 理解 etcd 作为 Kubernetes 数据存储的重要性并相应地保护它。

### 2.5 错误处理模式

- **集中式错误处理：** 实施集中式错误处理机制以一致地处理异常和记录错误。
- **重试机制：** 实施重试机制自动重试失败的操作。
- **断路器模式：** 使用断路器模式防止分布式系统中的级联故障。
- **记录错误详情：** 记录详细的错误消息，包括堆栈跟踪和相关上下文，以帮助调试。
- **优雅降级：** 设计应用程序在发生错误时优雅地降级功能。
- **关键错误警报：** 设置警报在发生关键错误时通知管理员。

## 3. 性能考虑

### 3.1 优化技术

- **缓存：** 实施缓存以减少延迟并提高性能。
- **负载均衡：** 使用负载均衡在应用程序的多个实例间分配流量。
- **连接池：** 使用连接池重用数据库连接并减少开销。
- **压缩：** 使用压缩减少通过网络传输的数据大小。
- **Gzip：** 在 Web 服务器中启用 Gzip 压缩以减少 HTTP 响应大小。

### 3.2 内存管理

- **内存分析：** 使用内存分析工具识别内存泄漏并优化内存使用。
- **垃圾收集：** 理解应用程序使用的编程语言中垃圾收集的工作原理。
- **资源限制：** 为容器设置内存资源限制以防止它们消耗过多内存。
- **监控内存使用：** 定期监控内存使用以识别潜在问题。

### 3.3 渲染优化

- **最小化 DOM 操作：** 减少 DOM 操作次数以改善 Web 应用程序的渲染性能。
- **虚拟 DOM：** 使用虚拟 DOM 优化 Web 应用程序中的渲染更新。
- **延迟加载：** 使用延迟加载仅在需要时加载图像和其他资源。

### 3.4 包大小优化

- **代码压缩：** 使用代码压缩减少 JavaScript 和 CSS 文件的大小。
- **树摇：** 使用树摇从 JavaScript 包中删除未使用的代码。
- **图像优化：** 优化图像以在不牺牲质量的情况下减少文件大小。
- **代码分割：** 将应用程序代码分割为可按需加载的更小包。

### 3.5 延迟加载策略

- **按需加载：** 仅在应用程序需要时加载资源。
- **交叉观察器：** 使用交叉观察器 API 检测元素在视口中何时可见并相应地加载它们。
- **占位符图像：** 在加载实际图像时使用占位符图像以改善用户体验。

## 4. 安全最佳实践

### 4.1 常见漏洞及其预防方法

- **注入攻击：** 通过验证和清理所有用户输入防止注入攻击。
- **跨站脚本（XSS）：** 通过在浏览器中渲染前转义所有用户生成的内容防止 XSS 攻击。
- **跨站请求伪造（CSRF）：** 通过使用反 CSRF 令牌防止 CSRF 攻击。
- **身份验证和授权缺陷：** 实施强大的身份验证和授权机制保护敏感数据和资源。
- **安全配置错误：** 避免使用默认配置，确保所有组件都以安全为考虑进行适当配置。
- **使用已知漏洞的组件：** 保持所有依赖项最新以修补已知漏洞。
- **日志记录和监控不足：** 实施全面的日志记录和监控以检测和响应安全事件。
- **容器安全：** 遵循保护容器的最佳实践，如使用最小镜像、以非 root 身份运行和限制能力。
- **网络策略：** 使用网络策略限制 Pod 之间的网络流量。
- **RBAC（基于角色的访问控制）：** 实施 RBAC 控制对 Kubernetes 资源的访问。
- **机密管理：** 使用 Kubernetes Secrets 存储敏感信息，并对静态机密进行加密。
- **Pod 安全策略/Pod 安全标准：** 强制执行 Pod 安全标准以限制 Pod 的能力。

### 4.2 输入验证

- **验证所有输入：** 验证所有输入，包括用户输入、API 请求和配置数据。
- **使用强数据类型：** 使用强数据类型强制数据完整性。
- **清理输入：** 清理输入以删除潜在有害字符并防止注入攻击。
- **白名单输入：** 使用白名单方法仅允许已知良好的输入。
- **黑名单输入：** 避免使用黑名单方法，因为它容易被绕过。

### 4.3 身份验证和授权模式

- **多因素身份验证（MFA）：** 使用 MFA 增强身份验证安全性。
- **OAuth 2.0：** 使用 OAuth 2.0 进行授权和访问委托。
- **JSON Web 令牌（JWT）：** 使用 JWT 在各方之间安全传输声明。
- **基于角色的访问控制（RBAC）：** 实施 RBAC 根据角色控制对资源的访问。
- **最小权限原则：** 仅授予用户和应用程序必要的最小权限。

### 4.4 数据保护策略

- **静态加密：** 对静态敏感数据进行加密以保护其免受未授权访问。
- **传输加密：** 使用 HTTPS 或其他安全协议对传输中的敏感数据进行加密。
- **数据掩码：** 掩码敏感数据以防止其暴露给未授权用户。
- **数据匿名化：** 匿名化数据以删除个人身份信息（PII）。
- **数据丢失防护（DLP）：** 实施 DLP 措施防止敏感数据离开组织。

### 4.5 安全 API 通信

- **HTTPS：** 对所有 API 通信使用 HTTPS 以加密传输中的数据。
- **API 身份验证：** 实施 API 身份验证以验证客户端身份。
- **API 授权：** 实施 API 授权以控制对 API 端点的访问。
- **速率限制：** 实施速率限制以防止滥用和拒绝服务攻击。
- **输入验证：** 验证所有 API 请求以防止注入攻击和其他漏洞。

## 5. 测试方法

### 5.1 单元测试策略

- **测试驱动开发（TDD）：** 在编写应用程序代码之前编写单元测试。
- **模拟依赖项：** 使用模拟将被测试单元与其依赖项隔离。
- **测试边界条件：** 测试边界条件和边缘情况以确保代码正确处理它们。
- **测试错误条件：** 测试错误条件以确保代码优雅地处理错误。
- **代码覆盖率：** 追求高代码覆盖率以确保代码的所有部分都被测试。
- **表驱动测试：** 使用表驱动测试轻松测试多个输入和输出。

### 5.2 集成测试

- **测试组件间交互：** 测试应用程序不同组件之间的交互。
- **使用真实依赖项测试：** 为集成测试使用真实依赖项或集成模拟。
- **测试数据流：** 测试通过应用程序的数据流以确保数据被正确处理。
- **契约测试：** 使用契约测试确保服务遵守定义的契约。

### 5.3 端到端测试

- **测试整个系统：** 从端到端测试整个系统以确保所有组件正确协作。
- **自动化端到端测试：** 自动化端到端测试以确保定期运行。
- **使用现实测试数据：** 使用现实测试数据模拟真实世界场景。
- **CI/CD 集成：** 将端到端测试集成到 CI/CD 管道中。

### 5.4 测试组织

- **将测试与代码分离：** 在专用的 `test/` 目录中将测试与应用程序代码分离。
- **按组件组织测试：** 按组件或模块组织测试以便于查找和维护。
- **使用清晰的命名约定：** 为测试文件和测试函数使用清晰的命名约定。

### 5.5 模拟和存根

- **使用模拟框架：** 使用模拟框架简化模拟和存根的创建。
- **模拟外部依赖项：** 模拟外部依赖项（如数据库和 API）以隔离被测试单元。
- **存根响应：** 使用存根为外部依赖项提供预定义响应。
- **验证交互：** 验证被测试代码是否按预期与依赖项交互。

## 6. 常见陷阱和注意事项

### 6.1 开发人员常犯的错误

- **忽略错误处理：** 未能正确处理错误可能导致意外行为和崩溃。
- **不使用版本控制：** 不使用版本控制可能导致代码丢失和冲突。
- **硬编码配置：** 硬编码配置数据可能使在不同环境中部署应用程序变得困难。
- **不保护敏感数据：** 不保护敏感数据可能导致安全漏洞。
- **不彻底测试：** 不彻底测试可能导致错误和性能问题。
- **过度工程：** 向代码添加不必要的复杂性可能使其难以理解和维护。
- **过早优化：** 在必要之前优化代码可能浪费时间并使代码更难阅读。
- **不记录代码：** 不记录代码可能使其他人难以理解和维护。

### 6.2 需要注意的边缘情况

- **网络连接问题：** 优雅地处理网络连接问题。
- **资源耗尽：** 优雅地处理资源耗尽。
- **并发问题：** 通过使用适当的同步机制避免并发问题。
- **数据损坏：** 通过使用校验和和其他数据完整性技术防止数据损坏。
- **时区问题：** 在处理日期和时间时注意时区问题。

### 6.3 版本特定问题

- **API 版本兼容性：** 在升级 Kubernetes 或其他依赖项时注意 API 版本兼容性问题。
- **功能弃用：** 在升级 Kubernetes 或其他依赖项时注意功能弃用。
- **配置更改：** 在升级 Kubernetes 或其他依赖项时注意配置更改。

### 6.4 兼容性问题

- **操作系统兼容性：** 确保应用程序与目标操作系统兼容。
- **架构兼容性：** 确保应用程序与目标架构（例如，x86、ARM）兼容。
- **浏览器兼容性：** 确保 Web 应用程序与目标浏览器兼容。

### 6.5 调试策略

- **日志记录：** 使用详细的日志记录帮助识别问题的根本原因。
- **调试工具：** 使用调试工具（如调试器和分析器）分析代码并识别性能瓶颈。
- **远程调试：** 使用远程调试来调试在 Kubernetes 中运行的应用程序。
- **日志聚合：** 使用日志聚合工具（例如，Elasticsearch、Loki）集中和分析日志。
- **指标监控：** 使用指标监控工具（例如，Prometheus、Grafana）跟踪应用程序性能。
- **追踪：** 实施分布式追踪（例如，Jaeger、Zipkin）跟踪跨多个服务的请求。

## 7. 工具和环境

### 7.1 推荐的开发工具

- **IDE：** 使用支持应用程序使用的编程语言的现代 IDE（例如，VS Code、IntelliJ IDEA、GoLand）。
- **Kubectl：** 使用 `kubectl` 与 Kubernetes 集群交互。
- **Minikube/Kind：** 使用 Minikube 或 Kind 进行本地 Kubernetes 开发。
- **Helm：** 使用 Helm 管理 Kubernetes 包。
- **Kustomize：** 使用 Kustomize 自定义 Kubernetes 配置。
- **Docker：** 使用 Docker 构建和管理容器镜像。
- **Tilt：** 使用 Tilt 进行快速的本地 Kubernetes 开发。
- **Skaffold：** 使用 Skaffold 进行自动化构建、推送和部署工作流程。
- **Telepresence：** 使用 Telepresence 从本地机器调试在 Kubernetes 中运行的应用程序。

### 7.2 构建配置

- **Makefile：** 使用 Makefile 自动化常见构建任务。
- **CI/CD 管道：** 将构建过程集成到 CI/CD 管道中。
- **依赖管理：** 使用依赖管理工具（如 `go modules`）管理依赖项。
- **版本控制：** 使用版本控制跟踪构建配置的更改。

### 7.3 代码检查和格式化

- **代码检查器：** 使用代码检查器强制执行代码风格和最佳实践（例如，`golangci-lint`、`eslint`、`stylelint`）。
- **格式化器：** 使用格式化器根据预定义风格自动格式化代码（例如，`go fmt`、`prettier`）。
- **预提交钩子：** 使用预提交钩子在提交代码前运行代码检查器和格式化器。

### 7.4 部署最佳实践

- **基础设施即代码（IaC）：** 使用 IaC 工具（如 Terraform 或 CloudFormation）管理基础设施。
- **不可变基础设施：** 部署不可变基础设施以确保一致性和可重复性。
- **蓝绿部署：** 使用蓝绿部署在部署期间最小化停机时间。
- **金丝雀部署：** 使用金丝雀部署与小部分用户测试应用程序的新版本。
- **滚动更新：** 使用滚动更新以零停机时间逐步更新应用程序。
- **自动回滚：** 实施自动回滚以在出现问题时快速恢复到应用程序的先前版本。

### 7.5 CI/CD 集成

- **自动化测试：** 在 CI/CD 管道中自动化所有测试。
- **自动化部署：** 在 CI/CD 管道中自动化部署过程。
- **持续集成：** 使用持续集成在提交代码时自动构建和测试应用程序。
- **持续交付：** 使用持续交付在发布新版本时自动将应用程序部署到生产环境。
- **管道安全：** 保护 CI/CD 管道以防止未授权访问和代码注入。

## 参考文献

- Kubernetes 文档：[https://kubernetes.io/docs/](https://kubernetes.io/docs/)
- Kubernetes 最佳实践：[https://kubernetes.io/docs/concepts/configuration/overview/](https://kubernetes.io/docs/concepts/configuration/overview/)
- 应用程序安全检查清单：[https://kubernetes.io/docs/concepts/security/application-security-checklist/](https://kubernetes.io/docs/concepts/security/application-security-checklist/)
- Kubernetes 编码约定：[https://www.kubernetes.dev/docs/guide/coding-convention/](https://www.kubernetes.dev/docs/guide/coding-convention/)
