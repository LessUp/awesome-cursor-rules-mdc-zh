---
description: 此规则为 tRPC 最佳实践提供全面指导，涵盖代码组织、性能、安全、测试和常见陷阱，以确保强大且可维护的 tRPC 应用程序。
globs: "*.ts,*.tsx"
---
# tRPC 最佳实践：综合指南

本文档概述了使用 tRPC（TypeScript 远程过程调用）开发强大、可维护和高效应用程序的最佳实践。它涵盖从代码组织到安全考虑的各个方面，为开发人员提供可操作的指导。

## 1. 代码组织和结构

### 1.1 目录结构最佳实践

*   **基于功能的组织：** 围绕功能或模块组织代码，而不是技术层（例如，`components`、`utils`、`services`）。这促进了模块化和可维护性。例如：

    ```
    src/
    ├── features/
    │   ├── user/
    │   │   ├── components/
    │   │   │   ├── UserProfile.tsx
    │   │   │   └── UserSettings.tsx
    │   │   ├── api/
    │   │   │   ├── userRouter.ts  // 用户相关过程的 tRPC 路由器
    │   │   │   └── userSchema.ts // 输入验证的 Zod 模式
    │   │   ├── hooks/
    │   │   │   └── useUser.ts    // 数据获取和状态管理的自定义钩子
    │   │   └── types/
    │   │   │   └── user.ts        // 与用户相关的 TypeScript 类型
    │   ├── product/
    │   │   └── ...
    ├── utils/
    │   ├── api.ts      // tRPC 客户端初始化
    │   └── db.ts       // 数据库连接/抽象
    ├── app/
    │   ├── api/
    │   │   └── root.ts   // 组合所有功能路由器的根 tRPC 路由器
    │   └── context.ts // tRPC 上下文创建
    └── index.ts      // 服务器入口点
    ```

*   **关注点分离：** 将关注点分离到不同的目录和模块中。例如，将 tRPC 路由器定义与业务逻辑和数据访问层分开。
*   **分组相似功能：** 在功能目录中将相关文件保持在一起。这使代码更容易理解和维护。

### 1.2 文件命名约定

*   **描述性名称：** 为文件和目录使用清楚表明其目的的描述性名称。
*   **一致的大小写：** 保持一致的大小写约定（例如，变量使用 camelCase，组件使用 PascalCase）。文件名使用 `kebab-case`，例如 `user-profile.tsx` 或 `user.router.ts`
*   **后缀：** 使用后缀表示文件类型（例如，tRPC 路由器使用 `.router.ts`，Zod 模式使用 `.schema.ts`，React 组件使用 `.component.tsx`）。

### 1.3 模块组织

*   **小模块：** 保持模块小而专注。模块应该有单一职责。目标是易于理解和测试的模块。
*   **显式导出：** 使用显式导出控制从模块暴露的内容。这有助于防止意外暴露内部实现细节。
*   **循环依赖：** 避免模块之间的循环依赖。循环依赖可能导致意外行为并使代码难以推理。

### 1.4 组件架构

*   **展示型和容器型组件：** 将展示型（哑）组件与容器型（智能）组件分开。展示型组件专注于渲染 UI，而容器型组件处理数据获取和状态管理。在文件后缀中使用术语 `view` 而不是 `component` 可以区分 React 组件和展示型组件，例如 `user-profile.view.tsx`
*   **可重用组件：** 设计组件在应用程序的不同部分可重用。这减少了代码重复并提高了可维护性。
*   **组件组合：** 优先使用组件组合而不是继承。组合允许您创建更灵活和可重用的组件。

### 1.5 代码分割策略

*   **基于路由的分割：** 基于路由分割代码。这允许您仅加载特定路由所需的代码。这可以通过 React 的 `lazy` 和 `Suspense` API 轻松实现。
*   **基于组件的分割：** 基于组件分割代码。这允许您仅加载特定组件所需的代码。
*   **动态导入：** 使用动态导入按需加载代码。这对于加载不立即需要的大型库或组件很有用。

## 2. 常见模式和反模式

### 2.1 tRPC 特定的设计模式

*   **路由器组合：** 组合 tRPC 路由器创建分层 API 结构。这允许您将 API 组织成逻辑组。

    ```typescript
    // src/app/api/routers/userRouter.ts
    import { publicProcedure, router } from "../trpc";
    import { z } from "zod";

    export const userRouter = router({
      getById: publicProcedure
        .input(z.string())
        .query(async ({ input }) => {
          // ... 通过 ID 获取用户
        }),
      create: publicProcedure
        .input(z.object({ name: z.string() }))
        .mutation(async ({ input }) => {
          // ... 创建新用户
        }),
    });

    // src/app/api/root.ts
    import { userRouter } from "./routers/userRouter";
    import { productRouter } from "./routers/productRouter";

    export const appRouter = router({
      user: userRouter,
      product: productRouter,
    });

    export type AppRouter = typeof appRouter;
    ```

*   **中间件链：** 使用中间件处理横切关注点，如身份验证、授权和日志记录。中间件可以链接以创建操作管道。

    ```typescript
    // src/app/api/trpc.ts
    import { initTRPC, TRPCError } from "@trpc/server";
    import { Context } from "./context";

    const t = initTRPC.context<Context>().create();
    const isAuthed = t.middleware(({ ctx, next }) => {
      if (!ctx.user) {
        throw new TRPCError({ code: "UNAUTHORIZED" });
      }
      return next({
        ctx: {
          user: ctx.user,
        },
      });
    });

    export const router = t.router;
    export const publicProcedure = t.procedure;
    export const protectedProcedure = t.procedure.use(isAuthed);
    ```

*   **使用 Zod 进行输入验证：** 使用 Zod 进行输入验证以确保从客户端接收的数据有效。这有助于防止错误和安全漏洞。

    ```typescript
    import { z } from "zod";
    import { publicProcedure } from "../trpc";

    export const createUserProcedure = publicProcedure
      .input(z.object({ name: z.string().min(3), email: z.string().email() }))
      .mutation(async ({ input }) => {
        // ... 创建新用户
      });
    ```

### 2.2 常见任务的推荐方法

*   **身份验证：** 使用 tRPC 中间件对用户进行身份验证。验证用户凭据并在上下文中设置用户对象。
*   **授权：** 使用 tRPC 中间件对用户进行授权。检查用户是否具有访问资源所需的权限。
*   **错误处理：** 使用 tRPC 的内置错误处理机制优雅地处理错误。抛出带有适当错误代码和消息的 `TRPCError` 异常。
*   **数据获取：** 使用数据获取库（例如，Prisma、Drizzle ORM、Supabase）与数据库交互。将数据访问逻辑抽象到单独的模块或服务中。

### 2.3 要避免的反模式和代码异味

*   **过度获取：** 避免获取超过需要的数据。使用投影或 GraphQL 风格的查询仅获取所需字段。
*   **获取不足：** 避免进行多个 API 调用来获取相关数据。批处理请求或使用数据加载器模式在单个调用中获取相关数据。
*   **紧耦合：** 避免 tRPC 路由器与业务逻辑之间的紧耦合。将业务逻辑抽象到单独的模块或服务中。
*   **忽略错误：** 永远不要忽略错误。始终优雅地处理错误并向客户端提供有意义的反馈。
*   **在路由器中直接访问数据库：** 避免在 tRPC 路由器过程中直接访问数据库。相反，将数据访问抽象到单独的服务或存储库中。
*   **路由器中的复杂业务逻辑：** 保持 tRPC 路由器过程专注于路由和输入验证。将复杂的业务逻辑移到单独的函数或模块中。

### 2.4 状态管理最佳实践

*   **集中式状态管理：** 使用集中式状态管理库（例如，Zustand、Redux、Jotai）管理应用程序状态。这使得在组件之间共享状态和推理应用程序状态变得更容易。
*   **不可变状态：** 使用不可变状态防止意外副作用。这使得推理应用程序状态和调试问题变得更容易。
*   **受控组件：** 使用受控组件管理表单状态。这为您提供对表单的更多控制，并使验证输入变得更容易。
*   **服务器状态管理：** 使用 TanStack Query 或 SWR 等库管理服务器状态（从 API 获取的数据）。这些库提供缓存、乐观更新和其他功能，使管理服务器状态变得更容易。

### 2.5 错误处理模式

*   **集中式错误处理：** 使用集中式错误处理机制在整个应用程序中一致地处理错误。
*   **错误边界：** 使用错误边界防止错误使应用程序崩溃。错误边界可以捕获渲染期间发生的错误并显示回退 UI。
*   **日志记录：** 将错误记录到中央日志记录服务。这使得跟踪和修复问题变得更容易。
*   **用户友好的错误消息：** 向用户显示用户友好的错误消息。避免显示技术细节或堆栈跟踪。
*   **重试机制：** 为瞬态错误实施重试机制。这可以提高应用程序的弹性。

## 3. 性能考虑

### 3.1 优化技术

*   **缓存：** 实施缓存以减少 API 调用次数。在服务器和客户端上缓存数据。
*   **压缩：** 使用压缩减少 API 响应的大小。这可以提高应用程序的性能，特别是在慢速网络上。
*   **代码分割：** 将代码分割成更小的块以减少初始加载时间。根据需要按需加载代码。
*   **防抖和节流：** 使用防抖和节流减少用户输入触发的 API 调用次数。
*   **高效的数据结构：** 使用高效的数据结构存储和处理数据。为手头的任务选择正确的数据结构。

### 3.2 内存管理

*   **避免内存泄漏：** 小心避免内存泄漏。内存泄漏可能导致应用程序变慢并最终崩溃。
*   **垃圾收集：** 了解 JavaScript 中垃圾收集的工作原理。这可以帮助您避免内存泄漏并优化内存使用。
*   **使用弱引用：** 使用弱引用避免将对象在内存中保留超过必要时间。

### 3.3 渲染优化

*   **记忆化：** 使用记忆化避免不必要地重新渲染组件。记忆化多次接收相同 props 的组件。
*   **虚拟化：** 使用虚拟化高效渲染大型列表。虚拟化仅渲染屏幕上可见的项目。
*   **批量更新：** 批量更新以减少重新渲染次数。React 的 `useState` 钩子自动批量更新。

### 3.4 包大小优化

*   **树摇：** 使用树摇从包中删除未使用的代码。这可以显著减少包大小。
*   **代码压缩：** 压缩代码以减少包大小。压缩从代码中删除空白和注释。
*   **图像优化：** 优化图像以减少包大小。使用适当的图像格式并压缩图像。
*   **依赖分析：** 分析依赖项以识别大型或不必要的依赖项。考虑用较小的替代品替换大型依赖项。

### 3.5 延迟加载策略

*   **延迟加载图像：** 延迟加载图像以改善初始加载时间。仅在图像在屏幕上可见时加载它们。
*   **延迟加载组件：** 延迟加载组件以改善初始加载时间。仅在需要组件时加载它们。
*   **延迟加载模块：** 延迟加载模块以改善初始加载时间。仅在需要模块时加载它们。

## 4. 安全最佳实践

### 4.1 常见漏洞及其预防方法

*   **跨站脚本（XSS）：** 通过转义用户输入和使用内容安全策略（CSP）防止 XSS 攻击。
*   **跨站请求伪造（CSRF）：** 通过使用 CSRF 令牌防止 CSRF 攻击。大多数框架都内置了 CSRF 保护支持。
*   **SQL 注入：** 通过使用参数化查询或 ORM 防止 SQL 注入攻击。
*   **身份验证和授权：** 实施强大的身份验证和授权机制保护敏感数据。
*   **速率限制：** 实施速率限制防止暴力攻击。
*   **拒绝服务（DoS）：** 实施措施防止 DoS 攻击，如速率限制和输入验证。

### 4.2 输入验证

*   **验证所有输入：** 验证来自客户端的所有输入，包括查询参数、请求体和标头。
*   **使用强类型：** 使用强类型定义输入数据的预期格式。这可以帮助防止类型相关的错误和安全漏洞。Zod 等工具在这里非常宝贵。
*   **清理输入：** 清理输入以删除潜在有害的字符或代码。这可以帮助防止 XSS 攻击。
*   **白名单输入：** 白名单允许的输入值。这比黑名单不允许的值更安全。

### 4.3 身份验证和授权模式

*   **JWT（JSON Web 令牌）：** 使用 JWT 进行身份验证。JWT 是在各方之间作为 JSON 对象安全传输信息的标准方式。
*   **OAuth 2.0：** 使用 OAuth 2.0 进行授权。OAuth 2.0 是委托资源访问的标准协议。
*   **基于角色的访问控制（RBAC）：** 使用 RBAC 根据用户角色控制对资源的访问。这使得管理权限和执行安全策略变得更容易。
*   **基于属性的访问控制（ABAC）：** 使用 ABAC 根据用户属性控制对资源的访问。这提供了对资源访问的更细粒度控制。

### 4.4 数据保护策略

*   **加密：** 对静态和传输中的敏感数据进行加密。使用强加密算法。
*   **哈希：** 对密码和其他敏感数据进行哈希。使用带盐的强哈希算法。
*   **数据掩码：** 在日志和其他输出中掩码敏感数据。这防止敏感数据意外暴露。
*   **数据编辑：** 从 API 响应中编辑敏感数据。这防止敏感数据暴露给未授权用户。

### 4.5 安全 API 通信

*   **HTTPS：** 对所有 API 通信使用 HTTPS。HTTPS 加密客户端和服务器之间的通信，保护其免受窃听和篡改。
*   **CORS（跨源资源共享）：** 配置 CORS 限制来自未授权域的 API 访问。这有助于防止跨站脚本攻击。
*   **速率限制：** 实施速率限制防止暴力攻击和 DoS 攻击。
*   **API 密钥：** 使用 API 密钥验证 API 客户端。这有助于防止对 API 的未授权访问。

## 5. 测试方法

### 5.1 单元测试策略

*   **测试单个函数和模块：** 单元测试应专注于独立测试单个函数和模块。
*   **模拟依赖项：** 模拟依赖项以隔离被测试的代码。这防止外部依赖项干扰测试。
*   **测试边缘情况：** 测试边缘情况以确保代码正确处理意外输入。
*   **测试错误处理：** 测试错误处理以确保代码优雅地处理错误。
*   **使用测试驱动开发（TDD）：** 考虑使用 TDD 在编写代码之前编写测试。这可以帮助改善代码设计并确保其可测试。

### 5.2 集成测试

*   **测试模块间交互：** 集成测试应专注于测试模块间的交互。这确保模块正确协作。
*   **使用真实依赖项：** 在集成测试中使用真实依赖项。这提供了更现实的测试条件。
*   **测试数据流：** 测试模块间的数据流以确保数据正确传递。

### 5.3 端到端测试

*   **测试整个应用程序：** 端到端测试应专注于测试整个应用程序，从用户界面到后端 API。
*   **使用测试自动化框架：** 使用测试自动化框架（例如，Cypress、Playwright）自动化端到端测试。这使得运行测试和验证应用程序正常工作变得更容易。
*   **测试用户流程：** 测试常见用户流程以确保用户可以完成重要任务。

### 5.4 测试组织

*   **按功能组织测试：** 按功能组织测试。这使得查找和运行特定功能的测试变得更容易。
*   **将测试与代码分开：** 将测试与代码分开。这防止测试被包含在生产包中。
*   **使用一致的命名约定：** 为测试使用一致的命名约定。这使得识别和理解测试变得更容易。

### 5.5 模拟和存根

*   **使用模拟框架：** 使用模拟框架（例如，Jest、Sinon）创建模拟和存根。这使得隔离被测试的代码变得更容易。
*   **模拟外部依赖项：** 模拟外部依赖项以防止它们干扰测试。
*   **存根 API 响应：** 存根 API 响应以控制 API 返回的数据。

## 6. 常见陷阱和注意事项

### 6.1 开发人员常犯的错误

*   **不验证输入：** 未能验证输入是一个常见错误，可能导致错误和安全漏洞。
*   **忽略错误：** 忽略错误可能使调试问题变得困难并导致意外行为。
*   **过度复杂化代码：** 过度复杂化代码可能使其难以理解和维护。
*   **不编写测试：** 不编写测试可能导致错误并使重构代码变得困难。
*   **错误的上下文使用：** 误解 tRPC 上下文的工作原理，特别是在处理中间件和身份验证时。

### 6.2 需要注意的边缘情况

*   **空输入：** 优雅地处理空输入。提供默认值或显示错误消息。
*   **无效输入：** 优雅地处理无效输入。向用户显示错误消息。
*   **网络错误：** 优雅地处理网络错误。向用户显示错误消息并提供重试请求的方法。
*   **服务器错误：** 优雅地处理服务器错误。向用户显示错误消息并在服务器上记录错误。
*   **并发问题：** 在处理共享资源时注意并发问题。使用锁或其他同步机制防止数据损坏。

### 6.3 版本特定问题

*   **破坏性变更：** 在升级 tRPC 时注意破坏性变更。仔细查看发布说明并相应更新代码。
*   **已弃用的功能：** 注意已弃用的功能。用推荐的替代品替换已弃用的功能。
*   **兼容性问题：** 注意与其他库的兼容性问题。在升级 tRPC 或其他库后彻底测试代码。

### 6.4 兼容性问题

*   **浏览器兼容性：** 确保代码与您支持的浏览器兼容。
*   **Node.js 版本兼容性：** 确保代码与您支持的 Node.js 版本兼容。
*   **TypeScript 版本兼容性：** 确保代码与您使用的 TypeScript 版本兼容。

### 6.5 调试策略

*   **使用调试工具：** 使用调试工具（例如，Chrome DevTools、VS Code 调试器）逐步执行代码并检查变量。
*   **添加日志语句：** 向代码添加日志语句以跟踪执行流程并识别错误。
*   **使用调试器：** 使用调试器暂停代码执行并检查应用程序状态。
*   **重现问题：** 尝试在受控环境中重现问题。这使得识别问题原因变得更容易。

## 7. 工具和环境

### 7.1 推荐的开发工具

*   **VS Code：** 使用 VS Code 作为 IDE。VS Code 为 TypeScript 和 JavaScript 开发提供出色支持。
*   **ESLint：** 使用 ESLint 强制执行代码风格并防止错误。
*   **Prettier：** 使用 Prettier 自动格式化代码。
*   **TypeScript 编译器：** 使用 TypeScript 编译器编译代码。
*   **npm 或 Yarn：** 使用 npm 或 Yarn 管理依赖项。
*   **测试框架：** Jest 是一个很好的测试框架

### 7.2 构建配置

*   **使用构建工具：** 使用构建工具（例如，Webpack、Parcel、Rollup）为生产打包代码。
*   **配置构建工具：** 配置构建工具优化包大小、压缩代码并执行树摇。
*   **使用环境变量：** 使用环境变量配置构建过程。

### 7.3 代码检查和格式化

*   **配置 ESLint：** 配置 ESLint 强制执行代码风格并防止错误。在整个项目中使用一致的代码风格。
*   **配置 Prettier：** 配置 Prettier 自动格式化代码。这确保代码格式一致。
*   **使用预提交钩子：** 使用预提交钩子在提交代码前运行 ESLint 和 Prettier。这防止提交有风格违规或错误的代码。

### 7.4 部署最佳实践

*   **使用部署平台：** 使用部署平台（例如，Vercel、Netlify、AWS）部署应用程序。
*   **配置部署平台：** 配置部署平台在更改推送到存储库时自动部署应用程序。
*   **使用环境变量：** 使用环境变量配置部署环境。
*   **监控应用程序：** 监控应用程序以识别和解决问题。

### 7.5 CI/CD 集成

*   **使用 CI/CD 工具：** 使用 CI/CD 工具（例如，GitHub Actions、GitLab CI、CircleCI）自动化构建、测试和部署过程。
*   **配置 CI/CD 工具：** 配置 CI/CD 工具自动运行测试、构建应用程序和部署应用程序。
*   **使用环境变量：** 使用环境变量配置 CI/CD 环境。

通过遵循这些最佳实践，您可以使用 tRPC 构建强大、可维护和高效的应用程序。
