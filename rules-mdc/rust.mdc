---
description: 此规则为 Rust 开发提供全面的最佳实践，涵盖代码组织、常见模式、性能、安全、测试、陷阱和工具。旨在指导开发人员编写惯用、高效、安全和可维护的 Rust 代码。
globs: "*.rs"
---
# Rust 最佳实践

本文档概述了 Rust 开发的一套全面最佳实践，涵盖从代码组织到安全和工具的各个方面。遵循这些指南将帮助您编写惯用、高效、安全和可维护的 Rust 代码。

## 1. 代码组织和结构

### 1.1. 目录结构

-   **`src/`**: 包含所有 Rust 源代码。
    -   **`main.rs`**: 二进制 crate 的入口点。
    -   **`lib.rs`**: 库 crate 的入口点。
    -   **`bin/`**: 包含同一项目中多个二进制可执行文件的源文件。`bin/` 中的每个文件将被编译为单独的可执行文件。
    -   **`modules/` 或 `components/`**: （可选）对于大型项目，将相关模块或组件分组到子目录中。使用描述性名称。
    -   **`tests/`**: 集成测试。（有关更多详细信息，请参阅下面的测试部分。）
    -   **`examples/`**: 演示如何使用库的示例代码。
-   **`benches/`**: 基准测试（使用 `criterion` 或类似工具）。
-   **`Cargo.toml`**: 项目清单文件。
-   **`Cargo.lock`**: 记录使用的依赖项的确切版本。**不要手动编辑。**
-   **`.gitignore`**: 指定 Git 应忽略的有意未跟踪文件。
-   **`README.md`**: 项目文档，包括使用说明、构建说明和许可证信息。
-   **`LICENSE`**: 包含项目的许可证。


my_project/
├── Cargo.toml
├── Cargo.lock
├── src/
│   ├── main.rs         # 二进制 crate 的入口点
│   ├── lib.rs          # 库 crate 的入口点
│   ├── modules/
│   │   ├── module_a.rs # crate 内的一个模块
│   │   └── module_b.rs # 另一个模块
│   └── bin/
│       ├── cli_tool.rs # 单独的二进制可执行文件
│       └── worker.rs   # 另一个二进制可执行文件
├── tests/
│   └── integration_test.rs # 集成测试
├── benches/
│   └── my_benchmark.rs # 使用 Criterion 的基准测试
├── examples/
│   └── example_usage.rs # 使用库的示例代码
├── README.md
└── LICENSE


### 1.2. 文件命名约定

-   Rust 源文件使用 `.rs` 扩展名。
-   模块文件（例如，`module_a.rs`）应以它们定义的模块命名。
-   文件名使用 snake_case（例如，`my_module.rs`）。

### 1.3. 模块组织

-   使用模块将代码组织成逻辑单元。
-   在 `lib.rs` 或 `main.rs` 中使用 `mod` 关键字声明模块。
-   使用 `pub mod` 使模块公开。
-   为每个模块创建单独的文件以提高可读性和可维护性。
-   使用 `use` 语句将其他模块的项引入作用域。

rust
// lib.rs

pub mod my_module;

mod internal_module; // 不公开


rust
// my_module.rs

pub fn my_function() {
    //...
}


### 1.4. 组件架构

-   对于大型应用程序，考虑使用基于组件的架构。
-   每个组件应负责应用程序功能的特定部分。
-   组件应通过明确定义的接口（trait）相互通信。
-   考虑使用依赖注入来解耦组件并提高可测试性。

### 1.5. 代码分割策略

-   将代码分割为更小、可重用的模块。
-   使用功能标志有条件地为不同平台或功能编译代码。
-   考虑使用动态链接（如果目标平台支持）来减少二进制大小。

## 2. 常见模式和反模式

### 2.1. 设计模式

-   **构建器模式**: 用于构造具有许多可选参数的复杂对象。
-   **工厂模式**: 用于创建对象而不指定其具体类型。
-   **观察者模式**: 用于实现事件驱动系统。
-   **策略模式**: 用于在运行时选择算法。
-   **访问者模式**: 用于向现有数据结构添加新操作而不修改它们。

### 2.2. 常见任务的推荐方法

-   **数据结构**: 使用 `Vec` 作为动态数组，`HashMap` 作为键值对，`HashSet` 作为唯一元素，`BTreeMap` 和 `BTreeSet` 作为排序集合。
-   **并发**: 使用 `Arc` 和 `Mutex` 进行共享可变状态，使用通道进行消息传递，使用 `rayon` crate 进行数据并行。
-   **异步编程**: 使用 `async` 和 `await` 编写异步代码。
-   **错误处理**: 使用 `Result` 类型处理可恢复错误，使用 `panic!` 处理不可恢复错误。

### 2.3. 反模式和代码异味

-   **不必要的克隆**: 除非绝对必要，否则避免克隆数据。使用引用代替。
-   **过度使用 `unwrap()` 调用**: 正确处理错误而不是使用 `unwrap()`，这可能导致程序恐慌。
-   **过度使用 `unsafe`**: 最小化 `unsafe` 代码的使用，并仔细审查任何不安全代码以确保其正确性。
-   **忽略编译器警告**: 将编译器警告视为错误并修复它们。
-   **过早优化**: 首先专注于编写清晰、正确的代码，然后仅在必要时进行优化。

### 2.4. 状态管理

-   **默认不可变性**: 优先使用不可变数据结构和返回新值而不是修改现有值的函数。
-   **所有权和借用**: 使用 Rust 的所有权和借用系统来管理内存并防止数据竞争。
-   **内部可变性**: 在必要时使用 `Cell`、`RefCell`、`Mutex` 和 `RwLock` 进行内部可变性，但要小心避免数据竞争。

### 2.5. 错误处理

-   **`Result<T, E>`**: 使用 `Result` 表示可能失败的操作。`T` 是成功类型，`E` 是错误类型。
-   **`Option<T>`**: 使用 `Option` 表示可能缺少值的情况。`Some(T)` 表示有值，`None` 表示无值。
-   **`?` 操作符**: 使用 `?` 操作符将错误向上传播到调用堆栈。
-   **自定义错误类型**: 使用枚举或结构定义自定义错误类型，以提供有关错误的更多上下文。
-   **`anyhow` 和 `thiserror` Crate**: 考虑使用 `anyhow` crate 进行简单错误处理，使用 `thiserror` crate 定义自定义错误类型。

## 3. 性能考虑

### 3.1. 优化技术

-   **性能分析**: 使用性能分析工具（例如，`perf`、`cargo flamegraph`）识别性能瓶颈。
-   **基准测试**: 使用基准测试工具（例如，`criterion`）测量代码更改的性能。
-   **零成本抽象**: 利用 Rust 的零成本抽象，如迭代器、闭包和泛型。
-   **内联**: 使用 `#[inline]` 属性鼓励编译器内联函数。
-   **LTO（链接时优化）**: 启用 LTO 通过跨 crate 边界优化来提高性能。

### 3.2. 内存管理

-   **最小化分配**: 通过重用内存和在可能时使用栈分配来减少分配和释放的次数。
-   **避免复制大型数据结构**: 使用引用或智能指针避免复制大型数据结构。
-   **使用高效的数据结构**: 根据性能特征为工作选择正确的数据结构。
-   **考虑 `Box` 和 `Rc`**: `Box` 用于单一所有权堆分配，`Rc` 和 `Arc` 用于共享所有权（后者线程安全）。

### 3.3. 渲染优化

-   **（如果 Rust 应用程序涉及渲染，例如游戏或 GUI，则相关）**
-   **批处理绘制调用**: 将多个绘制调用合并为单个绘制调用以减少开销。
-   **使用高效的数据结构**: 使用为渲染优化的数据结构，如顶点缓冲区和索引缓冲区。
-   **分析渲染性能**: 使用性能分析工具识别渲染瓶颈。

### 3.4. 包大小优化

-   **剥离调试符号**: 从发布构建中删除调试符号以减少二进制大小。
-   **启用 LTO**: LTO 还可以通过删除死代码来减少二进制大小。
-   **使用 `minisize` 配置文件**: 在 `Cargo.toml` 中创建 `minisize` 配置文件以优化大小。
-   **避免不必要的依赖项**: 仅包含绝对必要的依赖项。

### 3.5. 延迟加载

-   **按需加载资源**: 仅在需要时加载资源（例如，图像、声音、数据文件）。
-   **使用加载屏幕**: 在加载资源时显示加载屏幕。
-   **考虑流式传输**: 从磁盘或网络流式传输大型资源，而不是一次性加载所有资源。

## 4. 安全最佳实践

### 4.1. 常见漏洞

-   **缓冲区溢出**: 通过使用安全索引方法（例如，`get()`、`get_mut()`）和验证输入大小来防止缓冲区溢出。
-   **SQL 注入**: 通过使用参数化查询和转义用户输入来防止 SQL 注入。
-   **跨站脚本（XSS）**: 通过在渲染 HTML 时转义用户输入来防止 XSS。
-   **命令注入**: 通过避免使用带有用户提供参数的 `std::process::Command` 来防止命令注入。
-   **拒绝服务（DoS）**: 通过限制资源使用（例如，内存、CPU、网络连接）来防止 DoS 攻击。
-   **整数溢出**: 使用整数上的 `checked_add`、`checked_sub`、`checked_mul` 等方法来防止溢出。
-   **释放后使用**: Rust 的所有权系统在很大程度上防止了这种情况，但在使用 `unsafe` 代码或处理原始指针时要小心。
-   **数据竞争**: 通过使用适当的同步原语（`Mutex`、`RwLock`、通道）避免数据竞争。
-   **未初始化内存**: Rust 通常初始化内存，但 `unsafe` 代码可以绕过这一点。在处理未初始化内存时要小心。

### 4.2. 输入验证

-   **验证所有输入**: 验证来自外部源的所有输入，包括用户输入、网络数据和文件内容。
-   **使用白名单方法**: 定义一组允许的值并拒绝任何不匹配的输入。
-   **清理输入**: 从输入中删除或转义任何潜在危险字符。
-   **限制输入长度**: 限制输入字符串的长度以防止缓冲区溢出。
-   **检查数据类型**: 确保输入数据是预期类型。

### 4.3. 身份验证和授权

-   **使用强密码**: 要求用户创建强密码，并使用 Argon2 或 bcrypt 等哈希算法安全存储。
-   **实施双因素身份验证（2FA）**: 通过要求用户使用第二因素（如手机代码）进行身份验证来添加额外的安全层。
-   **使用 JSON Web 令牌（JWT）**: 使用 JWT 进行无状态身份验证和授权。
-   **实施基于角色的访问控制（RBAC）**: 定义具有特定权限的角色并将用户分配给这些角色。
-   **最小权限原则**: 仅授予用户执行其任务所需的最小权限。
-   **定期审计**: 定期对身份验证和授权机制进行安全审计。

### 4.4. 数据保护

-   **加密敏感数据**: 使用 AES-256 等强加密算法对静态和传输中的敏感数据进行加密。
-   **使用 HTTPS**: 使用 HTTPS 加密客户端和服务器之间的通信。
-   **保护 API 密钥**: 安全存储 API 密钥并限制其使用仅限于授权用户。
-   **安全处理机密**: 使用环境变量或专用机密管理工具（例如，Vault、AWS Secrets Manager）存储机密。
-   **避免硬编码机密**: 永远不要将机密直接硬编码到代码中。
-   **数据掩码/编辑**: 在记录或显示敏感数据时对其进行掩码或编辑。

### 4.5. 安全 API 通信

-   **使用 TLS/SSL**: 对所有 API 通信强制使用 TLS/SSL。
-   **验证证书**: 正确验证服务器证书以防止中间人攻击。
-   **速率限制**: 实施速率限制以防止滥用和 DoS 攻击。
-   **API 版本控制**: 使用 API 版本控制来维护向后兼容性并允许未来更改。
-   **输入和输出验证**: 彻底验证 API 的输入和输出。
-   **内容安全策略（CSP）**: 使用 CSP 标头防止 XSS 攻击。

## 5. 测试方法

### 5.1. 单元测试

-   **测试单个代码单元**: 编写单元测试以验证单个函数、模块和组件的正确性。
-   **使用 `#[test]` 属性**: 使用 `#[test]` 属性将函数标记为单元测试。
-   **使用 `assert!` 和 `assert_eq!`**: 使用 `assert!` 和 `assert_eq!` 宏检查代码是否按预期行为。
-   **测试驱动开发（TDD）**: 考虑在编写代码之前编写测试。
-   **表驱动测试**: 使用参数化测试或表驱动测试来测试具有不同输入的多个场景。

rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}


### 5.2. 集成测试

-   **测试组件之间的交互**: 编写集成测试以验证应用程序的不同组件是否正确协作。
-   **创建 `tests/` 目录**: 将集成测试放在项目根目录的 `tests/` 目录中。
-   **使用单独的测试文件**: 为每个集成测试创建单独的测试文件。

### 5.3. 端到端测试

-   **测试整个应用程序**: 编写端到端测试以验证整个应用程序是否按预期工作。
-   **使用测试框架**: 使用测试框架（例如，`cucumber`、`selenium`）自动化端到端测试。
-   **测试用户流程**: 测试常见用户流程以确保应用程序可用。

### 5.4. 测试组织

-   **按功能分组测试**: 根据测试的功能将测试组织到模块和子模块中。
-   **使用描述性测试名称**: 使用清楚指示测试正在验证什么的描述性测试名称。
-   **将测试与生产代码分离**: 将测试保存在单独的文件和目录中，以避免混乱生产代码。
-   **频繁运行测试**: 将测试集成到开发工作流程中并频繁运行以尽早发现错误。

### 5.5. 模拟和存根

-   **使用模拟库**: 使用模拟库（例如，`mockall`、`mockito`）创建用于测试的模拟对象。
-   **使用 trait 作为接口**: 定义接口的 trait 以启用模拟和存根。
-   **避免全局状态**: 避免全局状态以便更容易模拟和存根依赖项。

## 6. 常见陷阱和注意事项

### 6.1. 常见错误

-   **借用规则**: 误解 Rust 的借用规则可能导致编译时错误。确保您理解所有权、借用和生命周期。
-   **移动语义**: 注意移动语义以及它们如何影响所有权。数据默认被移动，而不是复制。
-   **生命周期注解**: 忘记生命周期注解可能导致编译时错误。在必要时注解生命周期。
-   **错误处理**: 不正确处理错误可能导致意外恐慌。使用 `Result` 和 `?` 操作符优雅地处理错误。
-   **不安全代码**: 过度使用或误用 `unsafe` 代码可能导致未定义行为和安全漏洞。

### 6.2. 边缘情况

-   **整数溢出**: 注意整数溢出并使用检查算术方法来防止它。
-   **Unicode**: 正确处理 Unicode 字符以避免意外行为。
-   **文件路径**: 正确处理文件路径，特别是在处理不同操作系统时。
-   **并发**: 在编写并发代码时要小心避免数据竞争和死锁。

### 6.3. 版本特定问题

-   **检查发布说明**: 查看 Rust 新版本的发布说明，以识别可能影响您代码的任何破坏性变更或新功能。
-   **使用 `rustup`**: 使用 `rustup` 管理多个 Rust 版本。
-   **更新依赖项**: 保持依赖项最新以利用错误修复和新功能。

### 6.4. 兼容性问题

-   **C 互操作性**: 在与 C 代码交互时要小心避免未定义行为。
-   **平台特定代码**: 使用条件编译处理平台特定代码。
-   **WebAssembly**: 在针对 Web 时注意 WebAssembly 的限制。

### 6.5. 调试策略

-   **使用 `println!`**: 使用 `println!` 语句打印调试信息。
-   **使用调试器**: 使用调试器（例如，`gdb`、`lldb`）逐步执行代码并检查变量。
-   **使用 `assert!`**: 使用 `assert!` 检查代码是否按预期行为。
-   **使用日志记录**: 使用日志记录库（例如，`log`、`tracing`）记录调试信息。
-   **Clippy**: 使用 Clippy 捕获常见错误并提高代码质量。
-   **cargo-flamegraph**: 使用 cargo-flamegraph 分析和可视化代码的执行。

## 7. 工具和环境

### 7.1. 推荐的开发工具

-   **Rustup**: 用于管理 Rust 工具链和版本。
-   **Cargo**: Rust 包管理器和构建工具。
-   **IDE/编辑器**: 带有 rust-analyzer 扩展的 VS Code、IntelliJ Rust 或其他支持 Rust 的编辑器。
-   **Clippy**: Rust 代码的代码检查器。
-   **Rustfmt**: Rust 代码的代码格式化器。
-   **Cargo-edit**: 用于轻松修改 `Cargo.toml` 依赖项的实用程序。
-   **Cargo-watch**: 在文件更改时自动运行测试。
-   **lldb 或 GDB**: Rust 应用程序的调试器。

### 7.2. 构建配置

-   **使用 `Cargo.toml`**: 在 `Cargo.toml` 文件中配置构建设置、依赖项和元数据。
-   **使用配置文件**: 为开发、发布和测试定义不同的构建配置文件。
-   **功能标志**: 使用功能标志有条件地为不同平台或功能编译代码。

toml
[package]
name = "my_project"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }

[dev-dependencies]
rand = "0.8"

[features]
default = ["serde"] # 'default' 功能启用 'serde'
expensive_feature = []

[profile.release]
opt-level = 3
debug = false
lto = true


### 7.3. 代码检查和格式化

-   **使用 Clippy**: 使用 Clippy 捕获常见错误并强制执行编码标准。
-   **使用 Rustfmt**: 使用 Rustfmt 根据 Rust 样式指南自动格式化代码。
-   **配置编辑器**: 配置编辑器在保存时自动运行 Clippy 和 Rustfmt。
-   **预提交钩子**: 设置预提交钩子在提交代码前运行 Clippy 和 Rustfmt。

shell
# 安装 Clippy
rustup component add clippy

# 运行 Clippy
cargo clippy

# 安装 Rustfmt
rustup component add rustfmt

# 运行 Rustfmt
cargo fmt


### 7.4. 部署最佳实践

-   **构建发布二进制文件**: 在发布模式下构建应用程序（`cargo build --release`）以优化性能。
-   **最小化依赖项**: 减少依赖项数量以最小化部署应用程序的大小。
-   **容器化（Docker）**: 使用 Docker 创建一致且可重现的部署环境。
-   **静态链接**: 考虑静态链接以创建单个可执行文件。
-   **进程管理器（systemd、supervisord）**: 使用进程管理器确保应用程序在崩溃时自动重启。

### 7.5. CI/CD 集成

-   **使用 CI/CD 系统**: 使用 CI/CD 系统（例如，GitHub Actions、GitLab CI、Jenkins）自动化构建、测试和部署过程。
-   **在 CI 上运行测试**: 在 CI 上运行单元测试、集成测试和端到端测试。
-   **在 CI 上运行代码检查器和格式化器**: 在 CI 上运行 Clippy 和 Rustfmt 以强制执行编码标准。
-   **自动化部署**: 自动化部署过程以减少手动工作和错误。


# GitHub Actions 工作流程示例
name: CI

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Install Rust
        run: rustup default stable

      - name: Build
        run: cargo build --verbose

      - name: Run tests
        run: cargo test --verbose

      - name: Run clippy
        run: cargo clippy -- -D warnings


通过遵循这些最佳实践，您可以编写高质量的 Rust 代码，这些代码高效、安全且可维护。记住要跟上最新的 Rust 功能和最佳实践，以持续提高您的技能和知识。
