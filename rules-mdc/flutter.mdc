---
description: Flutter 开发的综合指南和最佳实践，涵盖代码组织、性能优化、安全、测试和工具。
globs: "*.dart"
---
- 遵循官方 Flutter 风格指南。这为可维护和一致的代码奠定了基础。
- 使用最新稳定版本的 Flutter，及时了解新功能和安全补丁。在更新期间查看 Flutter 的破坏性变更和迁移指南。

## 1. 代码组织和结构

- **1.1 目录结构最佳实践：**
    - **`lib/`（源代码）：**
        - 使用基于功能的结构，将相关组件分组到模块中。
        - 示例：
           ```
           lib/
           ├── auth/
           │   ├── models/
           │   ├── providers/
           │   ├── screens/
           │   ├── services/
           │   ├── widgets/
           │   └── auth.dart
           ├── home/
           │   ├── models/
           │   ├── screens/
           │   ├── widgets/
           │   └── home.dart
           ├── common/
           │   ├── models/
           │   ├── widgets/
           │   └── utils/
           ├── core/
           │   ├── services/
           │   ├── theme/
           │   └── utils/
           ├── main.dart
           └── app.dart
           ```
    - **`test/`（测试）：** 镜像 `lib/` 结构以便于测试发现。
    - **`android/`、`ios/`、`web/`、`macos/`、`windows/`、`linux/`（平台特定代码）：** 包含平台特定的原生代码。除非必要，限制直接修改；利用 Flutter 的平台通道。
    - **`assets/`（资源）：** 存储图像、字体和其他静态资源。按类型组织子文件夹（例如，`images/`、`fonts/`、`data/`）。使用 `pubspec.yaml` 声明资源。

- **1.2 文件命名约定：**
    - 文件名使用 `snake_case`（例如，`user_profile_screen.dart`）。
    - 对于文件中的类，文件名通常反映它包含的主要类。示例：包含 `UserProfileScreen` 的 `user_profile_screen.dart`。
    - 例外：如果能提高清晰度，将多个相关枚举、typedef 或小型辅助函数分组到单个文件中是可以接受的。

- **1.3 模块组织：**
    - 模块封装特定功能或功能性。模块应具有明确定义的接口并最小化对其他模块的依赖。
    - 在每个模块内实施分层架构（例如，UI、业务逻辑、数据访问）。
    - 考虑为大型独立功能使用包，以促进跨项目的可重用性。

- **1.4 组件架构：**
    - 优先使用基于组件的架构，使用 Flutter 小部件。将复杂 UI 分解为更小的可重用小部件。
    - 将表示逻辑与业务逻辑分离。
    - 小部件应该是其输入数据（状态）的纯函数。
    - 遵循小部件设计的单一职责原则（SRP）。

- **1.5 代码分割策略：**
    - **延迟加载：** 按需加载功能以减少初始应用大小。
    - **基于路由的分割：** 基于应用路由分割代码。
    - **基于功能的分割：** 基于功能分割代码。
    - 使用 `dart:ui` 库的 `loadFontFromList` 或 `ImageProvider.loadBuffer` 动态加载字体或图像资源。

## 2. 常见模式和反模式

- **2.1 Flutter 特定的设计模式：**
    - **BLoC（业务逻辑组件）：** 将业务逻辑与 UI 分离，使代码更可测试和可维护。
    - **Provider：** 简单的依赖注入和状态管理解决方案。
    - **Riverpod：** Provider 的改进版本，具有编译时安全性。
    - **GetX：** 提供状态管理、依赖注入和路由管理的微框架。
    - **MVVM（模型-视图-视图模型）：** 另一种分离关注点的模式。通常与响应式编程一起使用。
    - **Redux/Flux：** 用于可预测的状态管理，特别是在复杂应用程序中。
    - **InheritedWidget：** 用于主题和配置的隐式依赖注入。

- **2.2 常见任务的推荐方法：**
    - **状态管理：** 选择适合应用复杂性的状态管理解决方案。
    - **网络：** 使用 `http` 包或 `dio` 进行 API 请求。
    - **异步操作：** 使用 `async/await` 处理异步操作。
    - **数据持久化：** 使用 `shared_preferences` 进行简单数据存储，或使用 SQLite（使用 `sqflite` 等包）或 NoSQL 数据库（使用 `hive` 或 `isar` 等包）进行结构化数据。
    - **导航：** 使用 `go_router` 或 `auto_route` 进行类型安全导航。
    - **表单处理：** 使用带有 `TextFormField` 和验证器的 `Form` 小部件。

- **2.3 要避免的反模式和代码异味：**
    - **巨大的小部件：** 具有过多逻辑或 UI 代码的小部件。将它们分解为更小的可重用组件。
    - **小部件中的逻辑：** 避免将业务逻辑直接放在小部件中。
    - **深度嵌套的小部件：** 可能导致性能问题和难以阅读的代码。简化小部件树。
    - **未管理的状态：** 忘记处置 `StreamSubscription` 或 `AnimationController` 等资源，导致内存泄漏。
    - **硬编码值：** 避免在代码中硬编码颜色、大小和字符串等值。使用常量或主题数据。
    - **忽略错误：** 不正确处理异常可能导致意外崩溃。使用 `try-catch` 块和日志记录。

- **2.4 状态管理最佳实践：**
    - 选择适合应用复杂性的状态管理解决方案。
    - 将状态保持在尽可能接近需要它的地方。避免为所有内容使用全局状态。
    - 使用不可变数据结构防止意外状态更改。
    - 将状态与 UI 组件分离以提高可测试性。
    - 正确管理副作用。
    - 考虑使用流的响应式编程进行复杂状态转换。

- **2.5 错误处理模式：**
    - 使用 `try-catch` 块处理异常。
    - 为特定错误场景实施自定义错误类。
    - 将错误记录到文件或远程服务以进行调试。
    - 显示用户友好的错误消息。
    - 使用 `ErrorWidget` 显示自定义错误屏幕。
    - 使用 `Future.catchError` 或 `Stream.handleError` 处理异步错误。

## 3. 性能考虑

- **3.1 优化技术：**
    - **避免不必要的小部件重建：** 为不可变小部件使用 `const` 构造函数，在 `StatefulWidget` 中使用 `shouldRebuild` 方法，为在列表中更改位置的小部件使用 `ValueKey`。
    - **最小化 `setState` 调用：** 使用状态管理解决方案优化状态更新。
    - **使用 `ListView.builder` 或 `GridView.builder`：** 对于大型列表或网格，延迟构建小部件。
    - **使用 `RepaintBoundary`：** 隔离不需要经常重绘的 UI 部分。
    - **谨慎使用 `Opacity` 和 `Clip`：** 这些操作可能很昂贵。
    - **小心使用 `Transform`：** 变换可能破坏批处理并导致额外的绘制调用。

- **3.2 内存管理：**
    - 在 `dispose` 方法中处置 `StreamSubscription`、`AnimationController` 和 `TextEditingController` 等资源。
    - 避免创建不必要的对象。
    - 使用 `dart:developer` 包的内存分析工具识别内存泄漏。
    - 最小化全局变量和静态字段的使用。

- **3.3 渲染优化：**
    - 使用 Flutter Performance Overlay 识别性能瓶颈。
    - 减少小部件树的复杂性。
    - 优化图像加载和缓存。
    - 除非必要，避免使用自定义绘制操作。

- **3.4 包大小优化：**
    - 使用 `flutter build apk --split-per-abi` 或 `flutter build appbundle` 按 ABI（应用程序二进制接口）分割 APK/AAB。
    - 删除未使用的资源和代码。
    - 压缩图像。
    - 使用代码混淆和压缩。
    - 对不常用功能使用延迟加载。

- **3.5 延迟加载策略：**
    - **图像延迟加载：** 仅在图像在屏幕上可见时加载它们。
    - **数据延迟加载：** 在用户滚动时分块加载数据。
    - 使用 `VisibilityDetector` 包检测小部件何时变为可见。
    - 对大型数据集使用分页或无限滚动。

## 4. 安全最佳实践

- **4.1 常见漏洞及其预防方法：**
    - **数据注入：** 清理用户输入以防止 SQL 注入、XSS 和其他注入攻击。
    - **敏感数据存储：** 避免以明文存储敏感数据。使用加密和安全存储机制。
    - **不安全的 API 通信：** 对所有 API 通信使用 HTTPS。
    - **代码篡改：** 使用代码混淆使逆向工程应用变得更困难。
    - **中间人攻击：** 实施证书固定防止 MITM 攻击。

- **4.2 输入验证：**
    - 在客户端和服务器端验证所有用户输入。
    - 使用正则表达式或自定义验证逻辑强制执行数据约束。
    - 在 UI 中显示数据之前正确编码数据。

- **4.3 身份验证和授权模式：**
    - 使用 OAuth 2.0 或 OpenID Connect 等安全身份验证协议。
    - 实施多因素身份验证（MFA）增强安全性。
    - 使用基于角色的访问控制（RBAC）限制对敏感数据和功能的访问。
    - 安全存储身份验证令牌。

- **4.4 数据保护策略：**
    - 对静态和传输中的敏感数据进行加密。
    - 使用 Keychain（iOS）或 Keystore（Android）等安全存储机制。
    - 在授予数据访问权限时遵循最小权限原则。

- **4.5 安全 API 通信：**
    - 对所有 API 通信使用 HTTPS。
    - 实施适当的身份验证和授权。
    - 验证 API 响应。
    - 限制 API 请求速率以防止滥用。

## 5. 测试方法

- **5.1 单元测试策略：**
    - 独立测试单个函数、类和小部件。
    - 使用模拟对象将被测试的代码与其依赖项隔离。
    - 为所有关键业务逻辑编写测试。

- **5.2 集成测试：**
    - 测试应用不同部分之间的交互。
    - 测试与 API 和数据库等外部服务的集成。

- **5.3 端到端测试：**
    - 从头到尾测试整个应用。
    - 模拟用户交互以确保应用按预期工作。

- **5.4 测试组织：**
    - 创建镜像 `lib/` 目录结构的 `test/` 目录。
    - 使用描述性测试名称。
    - 保持测试小而专注。

- **5.5 模拟和存根：**
    - 使用 `mockito` 等模拟框架创建模拟对象。
    - 使用存根用预定义值替换外部依赖项。
    - 避免过度模拟，因为这可能使测试效果降低。

## 6. 常见陷阱和注意事项

- **6.1 开发人员常犯的错误：**
    - 不处置资源。
    - 忽略错误。
    - 硬编码值。
    - 过度使用 `setState`。
    - 创建巨大的小部件。
    - 不验证用户输入。
    - 过度复杂化状态管理。

- **6.2 需要注意的边缘情况：**
    - 网络连接问题。
    - 设备方向变化。
    - 后台应用状态。
    - 低内存条件。
    - 本地化和国际化。

- **6.3 版本特定问题：**
    - 注意新 Flutter 版本中的破坏性变更。
    - 在不同 Flutter 版本上测试应用以确保兼容性。
    - 在 `pubspec.yaml` 中使用版本约束指定所需的 Flutter 版本。

- **6.4 兼容性问题：**
    - 在不同设备和操作系统上测试应用。
    - 考虑残障用户的可访问性。
    - 遵循 UI 和功能的平台特定指南。

- **6.5 调试策略：**
    - 使用 Flutter DevTools 进行调试和分析。
    - 使用日志记录跟踪错误。
    - 使用断点逐步执行代码。
    - 使用 Flutter Inspector 检查小部件树。

## 7. 工具和环境

- **7.1 推荐的开发工具：**
    - Visual Studio Code 或 Android Studio。
    - Flutter DevTools。
    - Android 模拟器或 iOS 模拟器。
    - Git 版本控制。

- **7.2 构建配置：**
    - 使用 `flutter build` 为不同平台构建应用。
    - 在 `pubspec.yaml` 中配置构建设置。
    - 为开发、暂存和生产使用不同的构建配置。

- **7.3 代码检查和格式化：**
    - 使用 `flutter_lints` 包进行代码检查。
    - 使用 `dart format` 或 Prettier 进行代码格式化。
    - 配置 IDE 在保存时自动格式化代码。

- **7.4 部署最佳实践：**
    - 遵循每个平台的部署指南。
    - 使用代码签名确保应用的真实性。
    - 使用版本控制管理发布。
    - 部署后监控应用的崩溃和错误。

- **7.5 CI/CD 集成：**
    - 使用 GitHub Actions、GitLab CI 或 Jenkins 等 CI/CD 工具自动化构建、测试和部署过程。
    - 配置 CI/CD 管道运行代码检查、格式化和测试。
    - 自动化向应用商店的发布过程。

本文档为 Flutter 开发提供了全面的指南和最佳实践。遵循这些指南将帮助您编写可维护、高性能和安全的 Flutter 应用。
