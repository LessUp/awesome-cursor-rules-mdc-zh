---
description: 本规范提供 PHP 编码最佳实践指导原则，涵盖代码结构、安全性、性能和测试，以提高代码质量和可维护性。
globs: "*.php"
---
# PHP 最佳实践和编码标准

本文档概述了 PHP 开发的最佳实践和编码标准，以确保代码质量、可维护性、安全性和性能。

## 1. 代码组织和结构

### 1.1. 目录结构最佳实践

*   **`src/`：** 包含应用程序或库的核心源代码。
*   **`public/`：** 应用程序的文档根目录，包含公开可访问的文件，如 `index.php`、CSS、JavaScript 和图像。所有请求都应通过此目录路由。
*   **`config/`：** 存储不同环境（开发、测试、生产）的配置文件。
*   **`tests/`：** 包含单元测试、集成测试和功能测试。
*   **`vendor/`：** 由 Composer 管理，包含第三方库和依赖项。不要手动修改内容。
*   **`cache/`：** 用于缓存数据的目录。
*   **`logs/`：** 存储应用程序日志的目录。为日志文件使用描述性名称。
*   **`data/`：** 存储数据文件（例如，SQLite 数据库）。
*   **`resources/`：** 包含视图模板、语言文件和其他资源。
*   **`migrations/`：** 数据库迁移文件，用于数据库架构的版本控制。

```
project/
├── src/
│   ├── Controller/
│   │   └── UserController.php
│   ├── Model/
│   │   └── User.php
│   └── ...
├── public/
│   └── index.php
├── config/
│   └── config.php
├── tests/
│   ├── Unit/
│   │   └── UserTest.php
│   └── ...
├── vendor/
│   └── ...
├── cache/
│   └── ...
├── logs/
│   └── app.log
├── data/
│   └── database.sqlite
├── resources/
│   ├── views/
│   │   └── user.php
│   └── lang/
│       └── en.php
└── migrations/
    └── 2024_01_01_create_users_table.php
```

### 1.2. 文件命名约定

*   **类：** 使用 PascalCase（例如，`UserController.php`）。文件名应与类名匹配。
*   **函数和方法：** 使用 camelCase（例如，`getUserById()`）。
*   **变量：** 使用 camelCase（例如，`$userName`）。
*   **常量：** 使用 UPPER_SNAKE_CASE（例如，`MAX_USER_AGE`）。
*   **配置文件：** 使用小写加下划线（例如，`database_config.php`）。
*   **视图文件：** 使用小写加连字符（例如，`user-profile.php`）。

### 1.3. 模块组织

*   **分离关注点：** 根据功能将代码组织成模块（例如，身份验证、用户管理、支付处理）。
*   **使用命名空间：** 在命名空间内分组相关类和接口，以避免命名冲突并改善代码组织（例如，`namespace App\Controllers;`）。遵循 PSR-4 自动加载标准。
*   **依赖注入：** 使用依赖注入解耦模块，使其更易于测试和维护。
*   **接口和抽象类：** 为模块定义接口以确保松耦合并允许不同的实现。

### 1.4. 组件架构

*   **组件：** 独立、可重用的功能片段，可以组合构建更大的应用程序。
*   **精简控制器：** 保持控制器轻量，将业务逻辑委托给服务类或模型层。
*   **仓储：** 从应用程序的其余部分抽象数据访问逻辑。这允许您轻松在不同数据源（例如，数据库、API）之间切换，而无需修改核心应用程序代码。
*   **服务：** 封装复杂的业务逻辑。

### 1.5. 代码分割

*   **延迟加载：** 仅在需要时加载模块或组件，以改善初始加载时间。
*   **Composer 自动加载：** Composer 基于命名空间高效处理类的自动加载，将代码分割为单独的文件。

## 2. 常见模式和反模式

### 2.1. 设计模式

*   **单例：** 确保类只有一个实例并提供对它的全局访问点。谨慎使用，因为过度使用可能导致紧耦合并使测试变得困难。
*   **工厂：** 创建对象而不指定要创建的确切类。对抽象对象创建很有用。
*   **观察者：** 定义对象之间的一对多依赖关系，以便当一个对象改变状态时，所有依赖者都会被通知并自动更新。对事件处理很有用。
*   **策略：** 定义算法族，封装每一个，并使它们可互换。让算法独立于使用它的客户端而变化。
*   **模型-视图-控制器（MVC）：** 分离应用程序逻辑（模型）、用户界面（视图）和输入处理（控制器）。大多数 PHP 框架都基于 MVC。
*   **仓储模式：** 抽象数据访问逻辑。当您希望能够轻松切换数据源或数据访问逻辑复杂时很有用。

### 2.2. 推荐方法

*   **数据库交互：** 使用带参数化查询的预处理语句防止 SQL 注入。
*   **模板：** 使用 Twig 或 Blade 等模板引擎将表示逻辑与 PHP 代码分离。有助于保持代码清洁和可读。
*   **路由：** 使用路由组件将 URL 映射到控制器和操作。简化 URL 处理。
*   **错误处理：** 使用异常和日志记录实现一致的错误处理策略。
*   **依赖注入：** 使用依赖注入容器管理依赖关系并促进松耦合。框架通常包含 DI 容器。

### 2.3. 反模式和代码异味

*   **全局状态：** 避免使用全局变量，因为它们可能导致不可预测的行为并使代码难以测试。
*   **紧耦合：** 最小化类和模块之间的依赖关系，以提高可重用性和可维护性。
*   **长方法/函数：** 将大型方法分解为更小、更专注的函数。
*   **复制粘贴代码：** 将通用功能提取到可重用的函数或类中。
*   **忽略错误：** 始终适当处理异常和记录错误。
*   **过度使用静态方法：** 限制静态方法的使用，这可能使测试更加困难。
*   **代码重复：** 遵循 DRY（不要重复自己）原则。

### 2.4. 状态管理

*   **会话：** 使用 PHP 会话管理用户身份验证和临时数据。配置会话安全设置（例如，`session.cookie_httponly`、`session.cookie_secure`）。
*   **Cookie：** 使用 cookie 在客户端存储少量数据。注意 cookie 大小限制和安全性。
*   **缓存：** 使用缓存机制（例如，Memcached、Redis、基于文件的缓存）通过存储频繁访问的数据来提高性能。
*   **数据库：** 在数据库中存储持久数据。使用适当的数据类型和索引以获得最佳性能。
*   **无状态：** 尽可能设计 API 为无状态以提高可扩展性。

### 2.5. 错误处理

*   **异常：** 使用异常处理错误和异常情况。当出现问题时抛出异常。
*   **Try-catch 块：** 将可能抛出异常的代码包装在 try-catch 块中以优雅地处理错误。
*   **自定义异常类：** 创建自定义异常类来表示应用程序中的特定错误条件。
*   **日志记录：** 使用日志库（例如，Monolog）记录错误、警告和信息消息。配置日志级别。
*   **错误报告：** 为不同环境适当配置 PHP 错误报告设置（`error_reporting`、`display_errors`）。在生产环境中禁用显示错误。
*   **全局异常处理程序：** 设置全局异常处理程序来捕获未捕获的异常并记录它们。

## 3. 性能考虑

### 3.1. 优化技术

*   **操作码缓存：** 使用 OPcache（内置于 PHP）等操作码缓存将编译的 PHP 代码存储在内存中，减少每次请求重新编译代码的需要。
*   **缓存：** 在不同级别实现缓存策略（例如，数据库缓存、对象缓存、页面缓存）。
*   **数据库优化：** 优化数据库查询，使用索引，避免 N+1 查询问题。
*   **代码分析：** 使用分析器（例如，Xdebug）识别代码中的性能瓶颈。
*   **最小化文件 I/O：** 减少文件读/写操作的数量。
*   **使用适当的数据结构：** 为您的需求选择正确的数据结构（例如，数组、链表、哈希表）。
*   **避免资源密集型操作：** 最小化使用消耗大量资源的函数（例如，正则表达式）。
*   **使用 PHP 7.x/8.x 功能：** 利用新版本 PHP 中的性能改进。

### 3.2. 内存管理

*   **取消设置变量：** 取消设置不再需要的变量以释放内存。
*   **避免大型数组：** 避免在数组中存储大量数据。如果可能，使用迭代器或生成器。
*   **垃圾回收：** PHP 使用垃圾回收自动管理内存。确保您的代码不会创建内存泄漏（例如，循环引用）。
*   **限制会话大小：** 注意会话中存储的数据量，因为大型会话可能消耗大量内存。

### 3.3. 渲染优化

*   **最小化 HTTP 请求：** 通过合并 CSS 和 JavaScript 文件、使用 CSS 精灵和内联小图像来减少 HTTP 请求数量。
*   **优化图像：** 压缩图像并使用适当的图像格式（例如，JPEG、PNG、WebP）。
*   **使用浏览器缓存：** 配置浏览器缓存以在浏览器缓存中存储静态资源（例如，CSS、JavaScript、图像）。
*   **内容分发网络（CDN）：** 使用 CDN 从地理分布的服务器提供静态资源。
*   **Gzip 压缩：** 启用 Gzip 压缩以减少 HTTP 响应的大小。
*   **压缩 HTML、CSS 和 JavaScript：** 从 HTML、CSS 和 JavaScript 文件中删除不必要的字符。

### 3.4. 包大小优化（对传统 PHP 不太相关，但对前端资源很重要）

*   **代码分割：** 将前端代码分割为可按需加载的较小块。（如果与 PHP 一起使用 React、Vue 或 Angular 等前端框架，则相关）。
*   **树摇：** 从 JavaScript 包中删除未使用的代码。（如果使用前端框架，则相关）。

### 3.5. 延迟加载

*   **延迟加载图像：** 仅在图像在视口中可见时加载图像。
*   **延迟加载模块：** 仅在需要时加载模块或组件。

## 4. 安全最佳实践

### 4.1. 常见漏洞

*   **SQL 注入：** 当不受信任的数据用于构造 SQL 查询时发生。通过使用带参数化查询的预处理语句防止。
*   **跨站脚本（XSS）：** 当恶意脚本被注入网站时发生。通过清理用户输入和转义输出防止。
*   **跨站请求伪造（CSRF）：** 当恶意网站欺骗用户在另一个网站上执行不需要的操作时发生。通过使用 CSRF 令牌防止。
*   **远程代码执行（RCE）：** 当攻击者可以在服务器上执行任意代码时发生。通过避免危险函数（例如，`eval()`、`system()`）和仔细验证用户输入防止。
*   **文件包含：** 当攻击者可以在服务器上包含任意文件时发生。通过仔细验证用户输入和限制文件访问防止。
*   **会话劫持：** 当攻击者窃取用户的会话 ID 时发生。通过使用安全的会话管理实践防止。
*   **拒绝服务（DoS）：** 当攻击者用请求压倒服务器，使其对合法用户不可用时发生。通过实施速率限制和其他安全措施防止。

### 4.2. 输入验证

*   **清理用户输入：** 从用户输入中删除或编码潜在危险字符。
*   **验证用户输入：** 验证用户输入是否符合预期格式和值。
*   **使用白名单：** 仅允许用户输入的已知良好值。避免黑名单，这很容易被绕过。
*   **转义输出：** 转义输出以防止 XSS 攻击。

### 4.3. 身份验证和授权

*   **使用强密码：** 强制执行强密码策略并使用安全的密码哈希算法（例如，bcrypt、Argon2）。
*   **加盐密码：** 在哈希之前为每个密码添加唯一的盐。
*   **安全存储密码：** 在安全数据库中存储密码哈希。
*   **实施访问控制：** 根据用户角色和权限限制对资源的访问。
*   **使用多因素身份验证（MFA）：** 通过要求用户提供多种形式的身份验证来添加额外的安全层。
*   **安全 cookie：** 在 cookie 上设置 `HttpOnly` 和 `Secure` 标志以防止 XSS 和中间人攻击。
*   **使用 HTTPS：** 使用 HTTPS 加密客户端和服务器之间的所有通信。

### 4.4. 数据保护

*   **加密敏感数据：** 对静态和传输中的敏感数据进行加密。
*   **安全使用加密密钥：** 将加密密钥存储在安全位置并定期轮换。
*   **遵守数据隐私法规：** 遵守 GDPR 和 CCPA 等数据隐私法规。
*   **实施数据掩码：** 在不需要处理时掩码敏感数据。
*   **定期备份数据：** 定期备份数据以防止数据丢失。

### 4.5. 安全的 API 通信

*   **使用 HTTPS：** 对所有 API 端点强制使用 HTTPS。
*   **验证 API 请求：** 使用 API 密钥、OAuth 2.0 或其他身份验证机制验证 API 客户端的身份。
*   **授权 API 请求：** 根据用户角色和权限限制对 API 端点的访问。
*   **限制 API 请求速率：** 实施速率限制以防止滥用。
*   **验证 API 输入：** 验证所有 API 输入以防止注入攻击。
*   **清理 API 输出：** 清理所有 API 输出以防止 XSS 攻击。
*   **记录 API 请求：** 记录所有 API 请求以进行审计和安全监控。

## 5. 测试方法

### 5.1. 单元测试

*   **测试单个代码单元：** 专注于独立测试单个函数、方法或类。
*   **使用测试框架：** 使用 PHPUnit 或 Codeception 等单元测试框架。
*   **编写可测试代码：** 设计代码易于测试（例如，使用依赖注入）。
*   **遵循 Arrange-Act-Assert 模式：** 安排测试数据，对被测代码执行操作，并断言预期结果。
*   **测试边缘情况：** 测试边缘情况和边界条件以确保代码正确处理意外输入。

### 5.2. 集成测试

*   **测试组件之间的交互：** 专注于测试应用程序不同组件之间的交互。
*   **使用测试框架：** 使用 PHPUnit 或 Codeception 等集成测试框架。
*   **测试数据库交互：** 测试数据库交互以确保数据正确存储和检索。
*   **测试 API 集成：** 测试 API 集成以确保数据正确交换。

### 5.3. 端到端测试

*   **测试整个应用程序流程：** 专注于从头到尾测试整个应用程序流程。
*   **使用测试框架：** 使用 Selenium 或 Cypress 等端到端测试框架。
*   **自动化测试：** 自动化端到端测试以确保应用程序在演进过程中继续正常工作。

### 5.4. 测试组织

*   **创建 `tests/` 目录：** 将所有测试文件存储在 `tests/` 目录中。
*   **镜像源代码结构：** 组织测试文件以镜像源代码结构（例如，`tests/Unit/UserControllerTest.php`）。
*   **使用命名空间：** 使用命名空间组织测试类。
*   **使用描述性测试名称：** 使用清楚表明正在测试什么的描述性测试名称。

### 5.5. 模拟和存根

*   **使用模拟隔离代码单元：** 使用模拟用受控测试替身替换依赖项。
*   **使用存根提供固定响应：** 使用存根从依赖项提供固定响应。
*   **使用模拟框架：** 使用 Mockery 或 Prophecy 等模拟框架。

## 6. 常见陷阱和注意事项

### 6.1. 常见错误

*   **不转义输出：** 未能转义输出，导致 XSS 漏洞。
*   **使用 `mysql_*` 函数：** 使用已弃用的 `mysql_*` 函数而不是 `mysqli_*` 或 PDO。
*   **不使用预处理语句：** 不使用带参数化查询的预处理语句，导致 SQL 注入漏洞。
*   **忽略错误：** 忽略错误和警告，使调试问题变得困难。
*   **不使用命名空间：** 不使用命名空间，导致命名冲突。
*   **过度复杂化代码：** 编写过于复杂的代码，难以理解和维护。
*   **不遵循编码标准：** 不遵循编码标准，导致代码不一致。

### 6.2. 边缘情况

*   **处理不同字符编码：** 正确处理不同字符编码。
*   **处理时区：** 正确处理时区。
*   **处理大文件上传：** 处理大文件上传而不耗尽内存。
*   **处理并发：** 在多线程应用程序中正确处理并发（在典型 Web 应用程序中不太常见）。

### 6.3. 版本特定问题

*   **已弃用功能：** 了解已弃用功能并用推荐的替代方案替换它们。
*   **兼容性问题：** 确保代码与不同版本的 PHP 兼容。

### 6.4. 兼容性问题

*   **数据库驱动程序：** 确保安装和配置正确的数据库驱动程序。
*   **Web 服务器配置：** 正确配置 Web 服务器（例如，Apache、Nginx）以提供 PHP 应用程序。
*   **操作系统兼容性：** 确保应用程序在不同操作系统上正确工作。

### 6.5. 调试策略

*   **使用调试器：** 使用调试器（例如，Xdebug）逐步执行代码并检查变量。
*   **记录消息：** 插入日志消息以跟踪执行流程并识别问题。
*   **使用 `var_dump()` 或 `print_r()`：** 使用 `var_dump()` 或 `print_r()` 检查变量和数据结构（在生产环境中谨慎使用）。
*   **阅读错误消息：** 仔细阅读错误消息和警告以了解问题的原因。
*   **使用检查器：** 使用检查器识别潜在错误和代码风格违规。

## 7. 工具和环境

### 7.1. 推荐的开发工具

*   **IDE：** PhpStorm、带 PHP 扩展的 VS Code。
*   **调试器：** Xdebug。
*   **包管理器：** Composer。
*   **数据库客户端：** DBeaver、phpMyAdmin。
*   **版本控制：** Git。
*   **虚拟化：** Docker、Vagrant。
*   **分析器：** Xdebug、Blackfire.io

### 7.2. 构建配置

*   **使用 Composer：** 使用 Composer 管理依赖项。
*   **在 `composer.json` 中定义依赖项：** 在 `composer.json` 文件中列出所有依赖项。
*   **使用语义版本控制：** 使用语义版本控制指定依赖项版本。
*   **使用 `composer.lock` 文件：** 将 `composer.lock` 文件提交到版本控制以确保每个人都使用相同版本的依赖项。
*   **配置自动加载：** 配置自动加载以自动加载类。

### 7.3. 代码检查和格式化

*   **使用检查器：** 使用检查器（例如，PHPStan、Psalm）识别潜在错误和代码风格违规。
*   **使用代码格式化程序：** 使用代码格式化程序（例如，PHP CS Fixer）根据编码标准自动格式化代码。
*   **配置检查和格式化规则：** 配置检查和格式化规则以强制执行编码标准。
*   **将检查和格式化集成到开发工作流程：** 将检查和格式化集成到开发工作流程中，以自动检查代码错误和风格违规。

### 7.4. 部署

*   **使用版本控制：** 使用版本控制跟踪代码更改。
*   **自动化部署：** 使用部署工具（例如，Deployer、Capistrano）自动化部署。
*   **使用环境变量：** 使用环境变量为不同环境配置应用程序设置。
*   **分离代码和配置：** 分离代码和配置以便更容易将应用程序部署到不同环境。
*   **使用构建过程：** 使用构建过程为部署准备代码（例如，运行检查器、格式化程序和测试）。
*   **测试部署：** 在部署到生产环境之前在暂存环境中测试部署。

### 7.5. CI/CD

*   **使用 CI/CD 平台：** 使用 CI/CD 平台（例如，Jenkins、Travis CI、CircleCI、GitHub Actions）自动化构建、测试和部署过程。
*   **配置 CI/CD 管道：** 配置 CI/CD 管道在每次提交时自动运行测试、检查器和格式化程序。
*   **自动化部署：** 使用 CI/CD 管道自动化部署。
*   **使用基础设施即代码：** 使用基础设施即代码（例如，Terraform、Ansible）管理基础设施。

本文档旨在提供 PHP 最佳实践和编码标准的全面概述。通过遵循这些指导原则，开发人员可以创建高质量、可维护、安全和高性能的 PHP 应用程序。
