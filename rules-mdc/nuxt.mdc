---
description: 此规则为 Nuxt.js 项目提供全面的最佳实践和编码标准，涵盖代码组织、性能、安全、测试和常见陷阱。旨在确保可维护、可扩展和安全的 Nuxt.js 应用程序。
globs: "*.vue,*.js,*.ts,*.mjs,*.mts,*.jsx,*.tsx,*.config.js,*.config.ts"
---
- **启用 ESLint 支持：** 使用 `@nuxt/eslint` 模块进行项目感知的 ESLint 配置。这确保代码质量和一致性。
  - `npx nuxi module add eslint` 添加模块。
  - 根据需要自定义生成的 `eslint.config.mjs` 文件。
- **采用 Nuxt.js 模块：** 利用 Nuxt.js 模块封装功能并维护清洁的代码库。在实施自定义解决方案之前探索现有模块（例如，`@nuxt/auth` 用于服务器端身份验证）。
- **约定优于配置：** 遵循 Nuxt.js 约定以简化开发和协作。除非绝对必要，避免偏离约定。
- **高效利用 Nuxt 布局：** 为跨多个页面共享的组件创建可重用布局，以确保一致性并节省开发时间。布局位于 `layouts/` 目录中。
- **使用 Pinia 管理状态：** 使用 Pinia 进行状态管理。根据功能或功能性组织存储模块以获得更好的可维护性。
- **将页面分解为组件：** 将页面分解为小的可重用组件以增强可维护性、可测试性和可重用性。每个组件应该有单一职责。
- **明智地利用 Nuxt 插件：** 使用 Nuxt 插件在 Vue.js 初始化之前运行代码或添加全局功能。注意插件性能影响。插件位于 `plugins/` 目录中。
- **针对 SEO 和性能进行优化：** 利用 Nuxt.js 的服务器端渲染（SSR）进行 SEO。为图像实施延迟加载并优化资源以最小化初始加载时间。使用 Lighthouse 等工具识别性能瓶颈。
- **实施错误处理和验证：** 实施强大的错误处理和验证机制以提供无缝的用户体验。使用 Nuxt.js 中间件拦截请求和响应进行错误处理和数据验证。
- **记录您的代码：** 使用 JSDoc 等工具为组件、模块和自定义函数提供清晰简洁的文档。
- **拥抱测试：** 使用 Jest、Vue Test Utils 和 Vitest 等工具编写单元测试、集成测试和端到端测试。

## 1. 代码组织和结构：

- **目录结构：**
  - `components/`：可重用的 Vue 组件。
  - `composables/`：可重用的组合函数。
  - `layouts/`：应用程序布局。
  - `middleware/`：路由中间件。
  - `pages/`：应用程序页面（路由定义）。
  - `plugins/`：Nuxt.js 插件。
  - `server/`：API 路由和服务器端逻辑。
  - `static/`：静态资源（例如，图像、字体）。
  - `store/`：Pinia 存储（可选，但推荐）。
  - `utils/`：实用函数。
- **文件命名约定：**
  - 组件：`PascalCase.vue`（例如，`MyComponent.vue`）
  - 组合函数：`usePascalCase.js` 或 `usePascalCase.ts`（例如，`useCounter.js`）
  - 布局：`kebab-case.vue`（例如，`default.vue` 或 `custom-layout.vue`）
  - 页面：`kebab-case.vue`（例如，`index.vue`、`about.vue`、`product-details.vue`）
  - 插件：`kebab-case.js` 或 `kebab-case.ts`（例如，`analytics.js`）
  - 存储：`kebab-case.js` 或 `kebab-case.ts`（例如，`user-store.js`）
  - 实用函数：`camelCase.js` 或 `camelCase.ts`（例如，`formatDate.js`）
- **模块组织：**
  - 将相关功能分组到单独的模块中。
  - 在 `nuxt.config.js` 或 `nuxt.config.ts` 中使用 `@nuxt/modules` 数组注册模块。
  - 创建自定义模块以封装复杂逻辑。
- **组件架构：**
  - 优先使用组合而不是继承。
  - 对简单 UI 元素使用函数式组件。
  - 设计组件以实现可重用性和可测试性。
  - 考虑使用插槽进行灵活的组件组合。
- **代码分割：**
  - 利用动态导入进行基于路由的代码分割。
  - 使用 `import()` 将大型组件分割为更小的块。
  - 使用 Webpack Bundle Analyzer 等工具分析包大小。

## 2. 常见模式和反模式：

- **设计模式：**
  - **组合 API：** 使用组合 API 组织组件逻辑。
  - **存储模式（Pinia）：** 使用 Pinia 实施集中式状态管理系统。
  - **中间件模式：** 使用中间件进行身份验证、授权和数据验证。
  - **插件模式：** 为全局功能和第三方库集成创建插件。
- **推荐方法：**
  - **API 通信：** 在组件内使用 `useFetch` 或 `useAsyncData` 组合函数进行 API 调用。
  - **表单处理：** 利用 Vue 的内置表单处理功能与 `v-model` 和 VeeValidate 等验证库。
  - **身份验证：** 使用 `@nuxt/auth` 等库或自定义解决方案实施安全身份验证流程。
  - **授权：** 使用中间件和 Pinia 存储实施基于角色的访问控制（RBAC）。
- **反模式：**
  - **直接修改属性：** 避免从子组件直接修改父组件数据。使用 `emit` 代替。
  - **过度使用全局状态：** 将全局状态的使用限制为基本应用程序数据。考虑为本地数据使用组件级状态。
  - **忽略错误处理：** 始终处理 API 调用和其他异步操作中的潜在错误。
  - **编写过于复杂的组件：** 将大型组件分解为更小、更易管理的部分。
- **状态管理最佳实践：**
  - **单一数据源：** 在 Pinia 存储中维护应用程序状态的单一、一致数据源。
  - **不可变性：** 将状态视为不可变。使用函数更新存储而不是直接操作数据。
  - **清晰的命名约定：** 为存储模块、动作和变更使用描述性名称。
  - **模块化：** 根据功能或功能性将存储分为模块。
- **错误处理模式：**
  - **集中式错误处理：** 实施全局错误处理程序以捕获未处理的异常。
  - **错误边界：** 使用错误边界隔离组件故障并防止级联错误。
  - **用户友好的错误消息：** 向用户提供清晰有用的错误消息。

## 3. 性能考虑：

- **优化技术：**
  - **延迟加载：** 为图像、组件和路由实施延迟加载。
  - **代码分割：** 将应用程序分割为更小的块以获得更快的初始加载时间。
  - **树摇：** 在构建过程中删除未使用的代码。
  - **缓存：** 缓存 API 响应和静态资源以减少服务器负载。
  - **图像优化：** 使用 `nuxt/image` 等工具优化图像。使用适当的图像格式（WebP）。将图像调整为适当大小。考虑使用 CDN 进行图像交付。
- **内存管理：**
  - **避免内存泄漏：** 在组件卸载时清理事件监听器和计时器。
  - **使用弱引用：** 尽可能对 DOM 元素使用弱引用。
  - **最小化对象创建：** 避免创建不必要的对象和数组。
- **渲染优化：**
  - **虚拟化：** 对大型列表使用虚拟化以提高渲染性能。
  - **记忆化：** 记忆化昂贵的计算以避免冗余计算。有效使用 `computed` 属性以避免不必要的重新渲染。
  - **防抖和节流：** 对事件处理程序使用防抖和节流以减少函数调用次数。
- **包大小优化：**
  - **分析包大小：** 使用 Webpack Bundle Analyzer 识别大型依赖项。
  - **删除未使用的依赖项：** 删除未使用的依赖项以减少包大小。
  - **使用更小的替代方案：** 考虑使用大型库的更小替代方案。
  - **优化依赖项：** 审查依赖项并确保您使用最高效的依赖项。
- **延迟加载策略：**
  - **基于路由的延迟加载：** 仅在访问相应路由时加载组件。
  - **基于组件的延迟加载：** 仅在组件在视口中可见时加载组件。

## 4. 安全最佳实践：

- **常见漏洞：**
  - **跨站脚本（XSS）：** 通过正确清理用户输入和使用 Vue 的内置 HTML 转义来防止 XSS 攻击。
  - **跨站请求伪造（CSRF）：** 通过实施 CSRF 令牌防止 CSRF 攻击。
  - **SQL 注入：** 避免原始 SQL 查询。使用 ORM（对象关系映射器）防止 SQL 注入。
  - **身份验证和授权缺陷：** 实施安全的身份验证和授权机制。
  - **不安全的直接对象引用（IDOR）：** 实施适当的访问控制以防止对资源的未授权访问。
- **输入验证：**
  - **服务器端验证：** 始终在服务器端验证用户输入。
  - **客户端验证：** 提供客户端验证以获得更好的用户体验（但不要依赖它作为验证的唯一来源）。
  - **清理输入：** 清理用户输入以删除潜在有害字符。
- **身份验证和授权模式：**
  - **JWT（JSON Web 令牌）：** 使用 JWT 进行身份验证和授权。
  - **OAuth 2.0：** 实施 OAuth 2.0 进行第三方身份验证。
  - **基于角色的访问控制（RBAC）：** 实施 RBAC 根据用户角色控制对资源的访问。
- **数据保护策略：**
  - **加密：** 对静态和传输中的敏感数据进行加密。
  - **哈希：** 使用强哈希算法对密码和其他敏感数据进行哈希。
  - **数据掩码：** 在日志和其他非生产环境中掩码敏感数据。
- **安全 API 通信：**
  - **HTTPS：** 始终对 API 通信使用 HTTPS。
  - **API 速率限制：** 实施 API 速率限制以防止滥用。
  - **身份验证和授权：** 对所有 API 端点要求身份验证和授权。

## 5. 测试方法：

- **单元测试：**
  - **测试单个组件：** 独立测试单个组件。
  - **模拟依赖项：** 模拟外部依赖项以在测试期间隔离组件。
  - **验证组件行为：** 验证组件正确渲染并按预期行为。
- **集成测试：**
  - **测试组件交互：** 测试组件之间的交互。
  - **测试数据流：** 测试组件和存储之间的数据流。
  - **测试 API 集成：** 测试与外部 API 的集成。
- **端到端测试：**
  - **模拟用户交互：** 模拟用户交互以测试应用程序的功能。
  - **测试整个应用程序流程：** 从开始到结束测试整个应用程序流程。
  - **使用浏览器自动化工具：** 使用 Cypress 或 Playwright 等浏览器自动化工具。
- **测试组织：**
  - **按功能组织测试：** 按功能或功能性组织测试。
  - **使用描述性测试名称：** 使用描述性测试名称清楚地指示每个测试正在测试什么。
  - **保持测试隔离：** 保持测试彼此隔离以避免干扰。
- **模拟和存根：**
  - **使用模拟对象：** 使用模拟对象在测试期间替换外部依赖项。
  - **使用存根：** 使用存根将复杂函数替换为简化版本。
  - **避免过度模拟：** 避免模拟太多代码，因为这会使测试效果降低。

## 6. 常见陷阱和注意事项：

- **常见错误：**
  - **错误的 `this` 上下文：** 注意 Vue 组件中的 `this` 上下文，使用箭头函数或 `bind` 维护正确的上下文。
  - **异步数据处理：** 使用 `async/await` 或 Promises 正确处理异步数据加载。
  - **忘记取消订阅：** 在组件卸载时取消订阅事件监听器和计时器以防止内存泄漏。
  - **过度使用 `forceUpdate`：** 除非绝对必要，避免使用 `forceUpdate`，因为它会对性能产生负面影响。
- **边缘情况：**
  - **服务器端渲染（SSR）：** 注意客户端和服务器端渲染之间的差异。
  - **浏览器兼容性：** 在不同浏览器中测试应用程序以确保兼容性。
  - **可访问性：** 在设计和开发应用程序时考虑可访问性。
- **版本特定问题：**
  - **Nuxt 2 vs Nuxt 3：** 注意 Nuxt 2 和 Nuxt 3 之间的差异。
  - **Vue 2 vs Vue 3：** 注意 Vue 2 和 Vue 3 之间的差异。
  - **依赖项更新：** 仔细审查依赖项更新的潜在破坏性变更。
- **兼容性问题：**
  - **浏览器支持：** 确保与目标浏览器的兼容性。
  - **设备兼容性：** 在不同设备上测试应用程序。
  - **操作系统兼容性：** 确保与目标操作系统的兼容性。
- **调试策略：**
  - **使用浏览器开发者工具：** 使用浏览器开发者工具检查应用程序的状态和网络活动。
  - **使用 Vue Devtools：** 使用 Vue Devtools 检查 Vue 组件和数据。
  - **使用日志记录：** 使用日志记录跟踪应用程序的行为。

## 7. 工具和环境：

- **推荐的开发工具：**
  - **VS Code：** Visual Studio Code 是一个流行的代码编辑器，具有出色的 Vue.js 支持。
  - **Vue Devtools：** Vue Devtools 是一个浏览器扩展，为 Vue.js 应用程序提供调试工具。
  - **ESLint：** ESLint 是一个强制执行编码标准的代码检查器。
  - **Prettier：** Prettier 是一个自动格式化代码的代码格式化器。
- **构建配置：**
  - **`nuxt.config.js` 或 `nuxt.config.ts`：** 在 `nuxt.config.js` 或 `nuxt.config.ts` 中配置应用程序的构建设置。
  - **Webpack：** Nuxt 使用 Webpack 打包应用程序。
  - **Vite：** Nuxt 3 默认使用 Vite 打包应用程序，提供更快的构建和开发时间。
- **代码检查和格式化：**
  - **ESLint：** 使用 ESLint 强制执行编码标准。
  - **Prettier：** 使用 Prettier 自动格式化代码。
  - **Husky：** 使用 Husky 在提交前运行代码检查器和格式化器。
- **部署最佳实践：**
  - **服务器端渲染（SSR）：** 将应用程序部署到支持 SSR 的服务器。
  - **静态站点生成（SSG）：** 为内容丰富的应用程序生成静态站点。
  - **CDN：** 使用 CDN 交付静态资源。
- **CI/CD 集成：**
  - **持续集成（CI）：** 使用 Jenkins、GitLab CI 或 GitHub Actions 等 CI 工具自动化构建和测试过程。
  - **持续部署（CD）：** 使用 CD 工具自动化部署过程。

通过遵循这些最佳实践，您可以构建强大、可维护和可扩展的 Nuxt.js 应用程序。
