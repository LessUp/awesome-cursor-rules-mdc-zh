---
description: 此规则文件为 Remix 开发提供全面的最佳实践，涵盖代码组织、性能、安全、测试等方面。旨在指导开发人员构建可维护、可扩展和安全的 Remix 应用程序。
globs: "*.js,*.jsx,*.ts,*.tsx"
---
## Remix 最佳实践和编码标准

本文档概述了开发 Remix 应用程序的推荐最佳实践和编码标准。遵循这些指南将促进代码一致性、可维护性、性能和安全性。

### 1. 代码组织和结构

#### 1.1. 目录结构

良好结构化的目录对于可维护性和可扩展性至关重要。以下是推荐的结构：


my-remix-app/
├── app/
│   ├── components/       # 可重用的 UI 组件
│   │   ├── Button.tsx
│   │   ├── Card.tsx
│   │   └── ...
│   ├── utils/            # 实用函数（例如，日期格式化、API 辅助函数）
│   │   ├── date-utils.ts
│   │   ├── api.ts
│   │   └── ...
│   ├── services/         # 业务逻辑和数据访问
│   │   ├── auth.server.ts  # 身份验证逻辑（仅服务器端）
│   │   ├── user.server.ts  # 用户数据访问（仅服务器端）
│   │   └── ...
│   ├── routes/            # Remix 路由模块
│   │   ├── _index.tsx       # 索引路由
│   │   ├── about.tsx        # 关于页面
│   │   ├── blog/
│   │   │   ├── $slug.tsx     # 动态博客文章路由
│   │   │   └── index.tsx     # 博客索引页面
│   │   ├── api/
│   │   │   ├── auth.ts        # 身份验证的 API 路由
│   │   │   └── ...
│   │   └── ...
│   ├── styles/            # 全局样式表
│   │   ├── global.css
│   │   └── ...
│   ├── entry.client.tsx   # 客户端入口点
│   ├── entry.server.tsx   # 服务器端入口点
│   ├── root.tsx           # 根组件（HTML 结构）
│   └── remix.env.d.ts
├── public/             # 静态资源（图像、字体等）
├── .gitignore
├── jsconfig.json
├── package-lock.json
├── package.json
├── remix.config.js
└── tsconfig.json


*   `components`：可重用的 UI 元素。将展示型组件与容器型组件分离（智能 vs 哑组件）。
*   `utils`：不特定于任何 React 组件的辅助函数。这促进了可重用性和可测试性。
*   `services`：处理服务器端交互的业务逻辑相关文件。
*   `routes`：定义应用程序的路由。每个文件代表一个路由段。对复杂布局和数据依赖使用嵌套路由。
*   `styles`：全局样式。
*   `public`：静态资源。

#### 1.2. 文件命名约定

*   **组件：** PascalCase（例如，`Button.tsx`）。
*   **路由模块：** kebab-case（例如，`about-us.tsx`）。对动态路由段使用 `$param`（例如，`$postId.tsx`）。
*   **实用函数：** camelCase（例如，`formatDate.ts`）。
*   **样式表：** kebab-case（例如，`global.css`）。
*   不包含 UI 的仅服务器端实用程序（例如 `auth.server.ts`）

#### 1.3. 模块组织

*   将相关组件、实用程序和服务分组到模块中。模块是包含协同工作以提供特定功能的文件的目录。这提高了代码的可发现性并减少了命名冲突。
*   使用索引文件（`index.ts` 或 `index.tsx`）重新导出模块中的成员，提供单一入口点。


components/
├── Button.tsx
├── Input.tsx
└── index.ts  # export { Button } from './Button'; export { Input } from './Input';


#### 1.4. 组件架构

*   **展示型 vs. 容器型组件：** 将处理数据获取和状态管理的组件（容器型组件）与仅渲染 UI 的组件（展示型组件）分离。这促进了可重用性和可测试性。
*   **组合：** 优先使用组合而不是继承。使用 React 的 `children` 属性或渲染属性创建灵活和可重用的组件。
*   **受控 vs 非受控组件：** 理解受控和非受控组件之间的区别。受控组件管理自己的状态，而非受控组件依赖于 DOM。

#### 1.5. 代码分割

*   Remix 自动处理基于路由的代码分割。每个路由模块独立加载，减少初始包大小。
*   对于较大的组件或模块，考虑使用动态导入（`React.lazy`）进一步分割代码。这对于页面加载时不立即需要的功能特别有用。
*   利用 Remix 对资源路由的内置支持来单独处理数据加载和后台任务，防止它们阻塞主 UI 线程。


### 2. 常见模式和反模式

#### 2.1. 设计模式

*   **复合组件：** 对需要隐式共享状态或逻辑的组件有用（例如，选项卡、手风琴）。使用 React Context 在父子组件之间提供通信。
*   **渲染属性/函数作为子元素：** 通过允许父组件控制其子元素的渲染提供最大灵活性。
*   **钩子：** 将可重用的有状态逻辑提取到自定义钩子中。这促进了代码重用并使组件更易读。
*   **提供者模式：** 用于管理全局状态或向组件子树提供上下文。

#### 2.2. 推荐方法

*   **数据加载：** 使用 Remix 加载器进行服务器端数据获取。这确保在组件渲染之前数据可用，提高性能和 SEO。
*   **数据变更：** 使用 Remix 动作处理表单提交和数据更新。这集中了数据变更并简化了状态管理。
*   **错误处理：** 在路由级别实施错误边界以捕获错误并防止整个应用程序崩溃。
*   **身份验证：** 使用服务器端会话或 cookie 实施身份验证。避免在客户端存储中存储敏感数据。
*   **授权：** 在加载器和动作中实施授权检查，确保用户只能访问授权资源。

#### 2.3. 反模式

*   **直接 DOM 操作：** 避免使用 `document.querySelector` 或 `document.getElementById` 直接操作 DOM。使用 React 的状态管理和渲染功能代替。
*   **过度依赖客户端状态：** 利用 Remix 的服务器端功能最小化客户端状态管理。这提高了性能并减少了状态不一致的风险。
*   **忽略服务器端渲染：** 利用 Remix 的服务器端渲染功能提高性能和 SEO。不要在客户端执行所有数据获取和渲染。
*   **JSX 中的复杂条件渲染：** 避免在 JSX 中深度嵌套条件渲染。将复杂逻辑提取到单独的函数或组件中。

#### 2.4. 状态管理

*   Remix 鼓励服务器端数据获取和变更，减少对复杂客户端状态管理的需求。
*   对于简单的组件级状态，使用 React 的 `useState` 钩子。
*   对于更复杂的应用程序级状态，考虑使用 Context API 与 `useReducer` 或 Zustand 或 Jotai 等状态管理库。
*   如果需要，谨慎集成 Redux 等第三方状态管理库，考虑 Remix 内置数据处理的好处。

#### 2.5. 错误处理

*   利用 Remix 的 ErrorBoundary 组件为路由创建专用错误屏幕。这在发生错误时提供更好的用户体验。
*   在加载器和动作中优雅地处理错误。返回错误响应或抛出异常以触发错误边界。
*   实施日志记录以跟踪错误和诊断问题。
*   避免在组件内使用 try-catch 块，依赖 ErrorBoundaries 进行全局异常处理。


### 3. 性能考虑

#### 3.1. 优化技术

*   **最小化包大小：** 删除未使用的代码，优化图像，使用代码分割减少初始包大小。
*   **优化数据获取：** 仅获取特定路由所需的数据。避免过度获取数据。
*   **缓存数据：** 使用 HTTP 缓存或服务器端缓存减少对服务器的请求次数。
*   **记忆化：** 使用 `React.memo` 或 `useMemo` 防止组件的不必要重新渲染。
*   **防抖和节流：** 使用防抖和节流限制事件处理程序的频率，提高用户输入和动画的性能。

#### 3.2. 内存管理

*   通过正确清理事件监听器和订阅避免内存泄漏。
*   使用带有清理函数的 `useEffect` 钩子在组件卸载时取消订阅。
*   避免在组件状态中存储大量数据。考虑使用服务器端数据存储或更高效的数据结构。

#### 3.3. 渲染优化

*   使用 `shouldComponentUpdate` 生命周期方法（或 `React.memo`）防止组件的不必要重新渲染。使用 React Profiler 仔细分析组件重新渲染。
*   虚拟化长列表或表格以提高渲染性能。
*   优化 CSS 并避免可能减慢渲染的复杂选择器。

#### 3.4. 包大小优化

*   使用 `webpack-bundle-analyzer` 或 `rollup-plugin-visualizer` 等工具分析包大小并识别优化区域。
*   删除未使用的依赖项并使用树摇来消除死代码。
*   使用代码分割仅加载特定路由或组件所需的代码。

#### 3.5. 延迟加载

*   使用 `React.lazy` 延迟加载页面加载时不立即需要的组件。这提高了初始加载时间。
*   使用 Intersection Observer API 在图像或其他资源在视口中可见时加载它们。


### 4. 安全最佳实践

#### 4.1. 常见漏洞

*   **跨站脚本（XSS）：** 通过清理用户输入和转义 HTML 实体防止 XSS 攻击。
*   **跨站请求伪造（CSRF）：** 通过在表单和 API 请求中使用反 CSRF 令牌防止 CSRF 攻击。
*   **SQL 注入：** 通过使用参数化查询或 ORM 防止 SQL 注入攻击。
*   **身份验证和授权问题：** 实施强大的身份验证和授权机制保护敏感数据和资源。

#### 4.2. 输入验证

*   在客户端和服务器端验证所有用户输入。
*   使用 Zod 或 Yup 等验证库为数据定义模式。
*   清理用户输入以删除潜在恶意字符或代码。

#### 4.3. 身份验证和授权

*   使用 OAuth 2.0 或 OpenID Connect 等安全身份验证协议。
*   使用哈希和盐安全存储用户凭据。
*   实施基于角色的访问控制（RBAC）限制对敏感资源的访问。
*   使用服务器端会话或 cookie 进行身份验证。避免在客户端存储中存储敏感数据。

#### 4.4. 数据保护

*   对静态和传输中的敏感数据进行加密。
*   使用 HTTPS 保护客户端和服务器之间的通信。
*   通过实施强访问控制和监控可疑活动防止数据泄露。
*   实施数据掩码或匿名化以保护开发和测试环境中的敏感数据。

#### 4.5. 安全 API 通信

*   使用 HTTPS 加密 API 通信。
*   实施 API 速率限制防止滥用。
*   验证 API 请求和响应防止数据注入攻击。
*   使用身份验证令牌授权 API 请求。


### 5. 测试方法

#### 5.1. 单元测试

*   为单个组件、实用程序和服务编写单元测试。
*   使用 Jest 或 Mocha 等测试框架。
*   模拟依赖项以隔离被测试的单元。
*   测试组件渲染、状态更新和事件处理程序。

#### 5.2. 集成测试

*   编写集成测试验证应用程序不同部分之间的交互。
*   测试组件、加载器和动作之间的数据流。
*   使用 React Testing Library 等测试库模拟用户交互。
*   模拟外部 API 和服务确保集成测试可靠。

#### 5.3. 端到端测试

*   编写端到端测试从用户角度验证整个应用程序流程。
*   使用 Cypress 或 Playwright 等测试框架。
*   测试用户身份验证、数据输入和导航。
*   在持续集成环境中运行端到端测试确保应用程序按预期工作。

#### 5.4. 测试组织

*   在镜像应用程序代码的目录结构中组织测试。
*   为每个组件、实用程序或服务创建单独的测试文件。
*   使用描述性测试名称清楚地传达每个测试的目的。
*   保持测试小而专注以提高可读性和可维护性。

#### 5.5. 模拟和存根

*   使用模拟和存根隔离被测试的单元并控制其依赖项。
*   使用 Jest 的 `jest.fn()` 或 Mock Service Worker (MSW) 等模拟库模拟 API 响应和外部服务。
*   避免过度模拟，这可能导致测试不能代表真实应用程序。


### 6. 常见陷阱和注意事项

#### 6.1. 常见错误

*   **错误使用加载器和动作：** 理解加载器和动作的生命周期和目的至关重要。错误使用可能导致性能问题和数据不一致。
*   **忽略服务器端渲染：** 未能利用 Remix 的服务器端渲染功能可能导致 SEO 和性能不佳。
*   **过度复杂化状态管理：** 对简单应用程序使用复杂状态管理库可能增加不必要的开销。
*   **不验证用户输入：** 未能验证用户输入可能导致安全漏洞和数据损坏。
*   **在服务器代码中使用浏览器特定 API**：在服务器代码中仅使用 Node.js 中可用的 Web 标准 API。

#### 6.2. 边缘情况

*   **处理空数据集：** 正确处理加载器返回空数据集的情况。向用户显示适当的消息。
*   **处理网络错误：** 实施强大的错误处理以优雅地处理网络错误和 API 故障。
*   **管理用户会话：** 实施安全会话管理保护用户数据并防止未授权访问。
*   **处理并发请求：** 注意处理对服务器的并发请求时的潜在竞态条件。

#### 6.3. 版本特定问题

*   保持最新的 Remix 版本并注意任何破坏性变更或错误修复。
*   查阅 Remix 文档和发布说明了解版本特定问题的信息。
*   升级到新版本的 Remix 后彻底测试应用程序。

#### 6.4. 兼容性问题

*   注意 Remix 与其他技术（如第三方库或服务器端环境）之间的兼容性问题。
*   在不同环境中彻底测试应用程序确保其按预期工作。
*   必要时使用 polyfills 或 shims 解决兼容性问题。

#### 6.5. 调试策略

*   使用浏览器的开发者工具调试客户端代码。
*   使用服务器端日志记录跟踪请求、响应和错误。
*   使用调试器逐步执行代码并检查变量。
*   使用分析工具识别性能瓶颈。


### 7. 工具和环境

#### 7.1. 推荐工具

*   **代码编辑器：** VS Code、Sublime Text 或 Atom，配备适当的 JavaScript/TypeScript、React 和 Remix 扩展。
*   **浏览器：** Chrome 或 Firefox，配备开发者工具进行调试和性能分析。
*   **测试框架：** Jest 或 Mocha。
*   **测试库：** React Testing Library 或 Enzyme。
*   **代码检查：** ESLint，配备推荐的 Remix 和 React 规则。
*   **格式化：** Prettier。

#### 7.2. 构建配置

*   使用 Remix 的内置构建配置获得最佳性能。
*   根据需要自定义构建配置以优化包大小和性能。
*   使用环境变量为不同环境配置应用程序。

#### 7.3. 代码检查和格式化

*   使用 ESLint 强制执行代码样式并防止错误。
*   使用 Prettier 自动格式化代码以保持一致性。
*   配置 ESLint 和 Prettier 无缝协作。
*   使用预提交钩子在提交代码前运行 ESLint 和 Prettier。

#### 7.4. 部署

*   将 Remix 应用程序部署到 Vercel 或 Netlify 等无服务器环境以获得最佳性能和可扩展性。
*   使用 Docker 等容器化平台打包和部署应用程序。
*   使用 CDN 缓存静态资源并提高交付速度。

#### 7.5. CI/CD 集成

*   使用持续集成/持续部署（CI/CD）管道自动化构建、测试和部署过程。
*   使用 GitHub Actions 或 GitLab CI 等 CI/CD 平台。
*   在 CI/CD 管道中自动化代码检查、格式化和测试。
*   在 CI/CD 管道中自动化部署到不同环境。
