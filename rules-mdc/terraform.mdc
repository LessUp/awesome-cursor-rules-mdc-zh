---
description: 此规则为 Terraform 最佳实践、编码标准和安全考虑提供指导，以确保可维护、高效和安全的基础设施即代码。
globs: "*.tf"
---
- **使用远程状态**：远程存储 Terraform 状态文件以启用协作并防止冲突。考虑使用 Terraform Cloud、HashiCorp Consul、带 DynamoDB 锁定的 AWS S3 或带 Blob 存储锁定的 Azure 存储账户。
	- 为远程状态后端正确配置访问控制以防止未授权访问。
	- 为状态文件实施版本控制以跟踪更改并促进回滚。
- **一致的命名约定**：为资源、模块和变量采用一致的命名约定以提高可读性和可维护性。
	- 为资源名称使用名词（例如，`aws_instance.web_server` 而不是 `web_server_instance`）。
	- 在名称中包含环境或项目上下文（例如，`dev_web_server` 或 `prod_db`）。
	- 遵循一致的大小写风格（例如，snake_case 或 camelCase）。
- **模块化和代码结构**：将 Terraform 代码组织成模块以促进可重用性和可维护性。
	- 为常见基础设施组件创建模块（例如，VPC、EC2 实例、数据库）。
	- 遵循标准模块结构（例如，`variables.tf`、`outputs.tf`、`main.tf`、`versions.tf`）。
	- 限制在模块内使用自定义脚本；优先使用 Terraform 资源和数据源。
- **验证和格式化**：始终使用 `terraform fmt` 和 `terraform validate` 验证和格式化 Terraform 代码以确保质量和一致性。
	- 将 `terraform fmt` 和 `terraform validate` 集成到 CI/CD 管道中。
	- 使用 TFLint 等代码检查器强制执行组织特定的编码最佳实践。
- **使用现有共享和社区模块**：利用 Terraform Registry 或其他可信来源的预构建模块以避免重复造轮子。
	- 在使用前彻底审查模块以了解其功能和安全影响。
	- 固定模块版本以防止意外更改。
- **导入现有基础设施**：使用 `terraform import` 命令将现有基础设施纳入 Terraform 管理。
	- 理解 `terraform import` 的限制并手动验证导入的配置。
- **避免硬编码变量**：使用变量参数化 Terraform 配置并避免硬编码值。
	- 在 `variables.tf` 中定义变量，包含适当的描述、类型和默认值。
	- 使用环境变量或 Terraform Cloud 变量传递敏感值。
- **标记资源**：为所有 Terraform 资源标记相关元数据（例如，`Name`、`Environment`、`Project`、`Owner`）。
	- 在基础设施中使用一致的标记约定。
	- 利用标记进行成本分配和资源管理。
- **引入策略即代码**：使用 HashiCorp Sentinel 或 Open Policy Agent (OPA) 等工具实施策略即代码以强制执行合规性和安全策略。
	- 为资源配置、命名约定和安全设置定义策略。
	- 将策略检查集成到 CI/CD 管道中。
- **代码组织和结构：**
	- **目录结构最佳实践：** 使用清晰的目录结构组织 Terraform 项目。常见模式：
		
		├── modules/
		│   ├── vpc/
		│   │   ├── main.tf
		│   │   ├── variables.tf
		│   │   └── outputs.tf
		│   ├── ec2/
		│   │   ├── main.tf
		│   │   ├── variables.tf
		│   │   └── outputs.tf
		├── environments/
		│   ├── dev/
		│   │   ├── main.tf
		│   │   ├── variables.tf
		│   │   └── terraform.tfvars
		│   ├── prod/
		│   │   ├── main.tf
		│   │   ├── variables.tf
		│   │   └── terraform.tfvars
		├── main.tf  # 顶级资源（如果有）
		├── variables.tf # 全局变量
		└── outputs.tf   # 全局输出
		
	- **文件命名约定：** 遵循一致的文件命名。使用 `main.tf` 作为主要资源定义，`variables.tf` 作为变量，`outputs.tf` 作为输出，`terraform.tfvars` 作为环境特定的变量值。
	- **模块组织：** 保持模块自包含和可重用。每个模块应有特定目的（例如，创建 VPC、EC2 实例或数据库）。
	- **组件架构：** 将基础设施设计为可组合在一起的松散耦合组件（模块）集合。
	- **代码分割策略：** 将大型配置分解为更小、更易管理的模块和文件。
- **常见模式和反模式：**
	- **设计模式：**
		- **单例模式：** 确保关键资源只存在一个实例（例如，VPC）。使用 `count = var.create_vpc ? 1 : 0` 有条件地创建单个 VPC。
		- **工厂模式：** 使用模块创建具有不同配置的资源的多个实例（例如，具有不同大小和角色的多个 EC2 实例）。
		- **外观模式：** 创建一个模块，通过抽象底层细节来简化复杂基础设施的创建。
	- **推荐方法：**
		- 使用数据源检索现有资源的信息，而不是硬编码其 ID 或名称。
		- 使用动态块根据变量值创建多个资源或配置资源属性。
		- 使用生命周期规则管理资源的创建、修改和删除。
	- **反模式：**
		- **硬编码值：** 避免在 Terraform 配置中硬编码值。使用变量代替。
		- **创建单体配置：** 将大型配置分解为更小、更易管理的模块。
		- **忽略错误：** 始终处理错误并提供有意义的错误消息。
	- **状态管理最佳实践：**
		- **远程状态：** 始终使用远程状态存储 Terraform 状态文件。
		- **状态锁定：** 启用状态锁定以防止并发修改。
		- **状态加密：** 加密状态文件以保护敏感数据。
		- **状态版本控制：** 为状态文件实施版本控制。
	- **错误处理模式：**
		- 使用 `try` 和 `can` 函数在检索数据或评估表达式时处理错误。
		- 使用 `validation` 块验证变量值并防止无效配置。
		- 提供有意义的错误消息以帮助用户诊断和修复问题。
- **性能考虑：**
	- **优化技术：**
		- 使用 `count` 和 `for_each` 元参数高效创建多个资源。
		- 使用数据源检索现有资源的信息而不是创建新资源。
		- 谨慎使用 `depends_on` 元参数以避免不必要的依赖关系。
	- **内存管理：**
		- 注意 Terraform 配置的内存使用，特别是在处理大型数据集时。
		- 避免创建可能消耗过多内存的大型变量或输出。
	- **渲染优化：**
		- 使用高效的字符串插值技术避免不必要的字符串连接。
		- 使用 `templatefile` 函数高效渲染复杂模板。
- **安全最佳实践：**
	- **常见漏洞：**
		- **硬编码机密：** 避免在 Terraform 配置中硬编码机密。
		- **公开可访问的资源：** 确保资源不公开可访问，除非明确需要。
		- **访问控制不足：** 实施严格的访问控制以防止对资源的未授权访问。
	- **输入验证：**
		- 验证变量值以防止无效或恶意输入。
		- 使用正则表达式强制执行特定输入格式。
	- **身份验证和授权模式：**
		- 使用 IAM 角色和策略为资源授予必要权限。
		- 使用 Terraform Cloud 或其他机密管理工具管理敏感凭据。
	- **数据保护策略：**
		- 对静态和传输中的敏感数据进行加密。
		- 使用密钥管理服务（KMS）管理的加密密钥。
	- **安全 API 通信：**
		- 对所有 API 通信使用 HTTPS。
		- 验证 API 响应以防止数据注入攻击。
- **测试方法：**
	- **单元测试策略：**
		- 使用 `terraform show` 和 `terraform plan` 验证 Terraform 配置创建预期资源。
		- 使用 `terratest` 或其他测试框架编写自动化单元测试。
	- **集成测试：**
		- 将 Terraform 配置部署到测试环境并验证资源是否正常运行。
		- 使用自动化测试工具执行集成测试。
	- **端到端测试：**
		- 模拟真实世界场景并验证基础设施能否处理它们。
		- 使用自动化测试工具执行端到端测试。
	- **测试组织：**
		- 将测试组织成清晰的目录结构。
		- 使用有意义的测试名称描述每个测试的目的。
	- **模拟和存根：**
		- 使用模拟和存根隔离测试并防止对外部资源的依赖。
		- 使用支持模拟和存根的测试框架。
- **常见陷阱和注意事项：**
	- **常见错误：**
		- **错误的资源依赖关系：** 确保正确定义资源依赖关系。
		- **忽略资源生命周期：** 理解 Terraform 资源的生命周期以及它们如何被创建、修改和删除。
		- **使用过时的 Terraform 版本：** 保持 Terraform 版本最新以利用新功能和错误修复。
	- **边缘情况：**
		- **处理资源冲突：** 准备处理同时应用多个 Terraform 配置时可能发生的资源冲突。
		- **管理具有外部依赖关系的资源：** 注意具有外部依赖关系的资源（例如，DNS 记录）并适当处理它们。
	- **版本特定问题：**
		- 在升级 Terraform 或提供程序版本时注意版本特定问题和兼容性问题。
		- 查阅 Terraform 和提供程序文档了解任何破坏性变更或迁移指南。
	- **兼容性问题：**
		- 确保 Terraform 配置与目标基础设施环境兼容。
		- 使用与 Terraform 版本兼容的提供程序版本。
	- **调试策略：**
		- 使用 `terraform plan` 命令预览将对基础设施进行的更改。
		- 使用带 `-auto-approve` 标志的 `terraform apply` 命令自动应用更改。
		- 使用 `terraform show` 命令检查基础设施的当前状态。
- **工具和环境：**
	- **推荐的开发工具：**
		- **Terraform CLI：** 官方 Terraform 命令行界面。
		- **Terraform Cloud/Enterprise：** Terraform 的协作和自动化平台。
		- **IDE/文本编辑器：** 带 Terraform 扩展的 Visual Studio Code、Atom 或 Sublime Text。
		- **TFLint：** Terraform 代码的代码检查器。
		- **Terratest：** Terraform 代码的测试框架。
	- **构建配置：**
		- 在所有环境中使用一致的构建配置。
		- 使用环境变量或 Terraform Cloud 变量配置构建环境。
	- **代码检查和格式化：**
		- 将代码检查和格式化集成到 CI/CD 管道中。
		- 使用 `terraform fmt` 和 TFLint 确保代码质量和一致性。
	- **部署最佳实践：**
		- 使用 CI/CD 管道自动化 Terraform 部署。
		- 使用版本控制跟踪 Terraform 配置的更改。
		- 使用基础设施即代码原则管理基础设施。
	- **CI/CD 集成：**
		- 使用 Jenkins、GitLab CI 或 GitHub Actions 等工具将 Terraform 集成到 CI/CD 管道中。
		- 自动化 `terraform plan` 和 `terraform apply` 命令的执行。
		- 将自动化测试和验证作为 CI/CD 过程的一部分实施。
