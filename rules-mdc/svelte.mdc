---
description: 全面的 Svelte 最佳实践，涵盖代码结构、性能、安全、测试和常见陷阱。此规则提供编写可维护、高效和安全的 Svelte 应用程序的指导。
globs: "*.svelte"
---
- **使用 HTML 操作 DOM：** 利用 Svelte 以 HTML 为中心的方法操作 DOM。
- **优先使用 HTML/CSS 解决问题：** 在使用 JavaScript 之前，优先使用 HTML 和 CSS 解决问题。
- **编写简短的组件：** 追求简洁和专注的组件以提高可读性和可维护性。
- **编写简洁的响应式 `$:` 块：** 保持响应式语句简短且易于理解。
- **将 CSS 作用域限定到实际组件：** 确保 CSS 样式作用域限定到组件以避免冲突。
- **避免硬编码数据或尺寸：** 使用动态数据和响应式设计技术而不是硬编码值。
- **保持对象不可变：** 将对象视为不可变以防止意外副作用并提高性能。
- **有效使用双向绑定：** 利用双向绑定进行高效的数据同步，但要注意其对复杂场景性能的潜在影响。

## 1. 代码组织和结构：

   - **目录结构最佳实践：**
      - `src/`：包含所有应用程序源代码。
      - `src/components/`：保存可重用的 Svelte 组件，按功能或领域进一步分类（例如，`src/components/Button/`、`src/components/Form/`）。
      - `src/lib/`：包含实用函数、辅助模块和不特定于组件的可重用逻辑。
      - `src/routes/`：对于 SvelteKit 应用程序，此目录定义应用程序的路由。
      - `src/stores/`：用于全局状态管理的存储（如果使用 Svelte 的存储）。
      - `static/`：静态资源，如图像、字体和其他资源。
   - **文件命名约定：**
      - 组件：使用 PascalCase（例如，`MyComponent.svelte`）。
      - 实用函数：使用 camelCase（例如，`formatDate.js`）。
      - 存储：使用与它们保存的数据相关的描述性名称（例如，`userStore.js`）。
   - **模块组织：**
      - 将相关组件和实用程序分组到各自目录内的模块中。
      - 使用 `index.js` 或 `index.svelte` 文件从目录导出多个组件或函数，提供更清洁的导入体验。
   - **组件架构：**
      - 优先使用基于组件的架构，将 UI 分解为小的可重用组件。
      - 考虑使用组合模式，通过组合更简单的组件来构建复杂组件。
      - 分离关注点：保持组件专注于表示逻辑，将数据获取或业务逻辑委托给服务或存储。
   - **代码分割策略：**
      - 使用动态导入（`import()`）按需加载组件或模块，减少初始包大小。
      - 利用 SvelteKit 的内置代码分割功能进行基于路由的分割。
      - 考虑将大型组件分割为更小的延迟加载子组件。

## 2. 常见模式和反模式：

   - **Svelte 特定的设计模式：**
      - **存储模式：** 使用 Svelte 的存储管理应用程序状态和响应性。
      - **动作模式：** 使用 Svelte 的动作操作 DOM 元素或与第三方库集成。
      - **组件组合：** 通过组合更小的可重用组件构建复杂的 UI。
   - **常见任务的推荐方法：**
      - **表单处理：** 对简单表单使用 Svelte 的双向绑定（`bind:value`）。对于更复杂的场景，考虑使用 Formik 或 Svelte Formly 等库。
      - **数据获取：** 使用 `fetch` 或 Axios 等库从 API 获取数据。适当处理加载和错误状态。
      - **事件处理：** 使用 Svelte 的事件指令（例如，`on:click`）处理 DOM 事件。
   - **要避免的反模式和代码异味：**
      - **过度使用全局状态：** 避免将所有内容放在全局存储中。在适当时使用组件级状态。
      - **在动作之外直接操作 DOM：** 依赖 Svelte 的响应性系统更新 DOM。
      - **编写过于复杂的组件：** 将大型组件分解为更小、更易管理的组件。
   - **状态管理最佳实践：**
      - 使用 Svelte 的内置存储管理全局或应用程序级状态。
      - 考虑使用响应式声明（`$:`）从其他状态变量派生状态。
      - 保持状态更新可预测，避免直接修改状态。
      - 对于复杂的状态管理需求，探索 Redux 或 Zustand 等库（尽管在 Svelte 中通常不必要）。
   - **错误处理模式：**
      - 使用 try-catch 块处理数据获取或其他异步操作期间的潜在错误。
      - 在 UI 中显示用户友好的错误消息。
      - 将错误记录到控制台或日志服务以进行调试。
      - 实施全局错误处理以捕获未处理的异常。

## 3. 性能考虑：

   - **优化技术：**
      - **最小化 DOM 更新：** Svelte 在更新 DOM 方面非常高效，但不必要的更新仍可能影响性能。明智地使用响应式声明。
      - **高效使用 `{#each}` 块：** 使用唯一标识符为您的 `{#each}` 块设置键，以帮助 Svelte 高效更新列表。
      - **避免不必要的组件重新渲染：** 有效使用 `$:` 语法仅在必要时更新组件。
   - **内存管理：**
      - 通过在组件销毁时正确清理事件监听器和订阅（使用 `onDestroy`）避免内存泄漏。
      - 注意存储中的大型数据结构，考虑使用分页或虚拟化等技术高效管理它们。
   - **渲染优化：**
      - 对接收不可变数据作为属性的组件使用带有 `immutable` 选项的 `svelte:options` 标签。
      - 使用 `shouldUpdate` 防止对未更改的不可变属性进行渲染。
   - **包大小优化：**
      - 使用带有压缩和树摇的生产构建来删除未使用的代码。
      - 使用动态导入进行代码分割。
      - 优化图像和其他资源。
   - **延迟加载策略：**
      - 使用动态导入延迟加载不立即需要的组件或模块。
      - 为位于折叠下方的图像或其他资源实施延迟加载。

## 4. 安全最佳实践：

   - **常见漏洞及其预防方法：**
      - **跨站脚本（XSS）：** 在 UI 中显示用户输入之前对其进行清理。Svelte 自动转义 HTML 实体，但在使用 `@html` 或 `{@debug}` 时要小心。
      - **跨站请求伪造（CSRF）：** 使用 CSRF 令牌防止 CSRF 攻击。
      - **SQL 注入：** 如果与数据库交互，使用参数化查询防止 SQL 注入攻击。
   - **输入验证：**
      - 在客户端和服务器端验证用户输入。
      - 使用适当的数据类型和验证规则防止处理无效数据。
   - **身份验证和授权模式：**
      - 使用 OAuth 或 JWT 等安全身份验证机制。
      - 实施适当的授权检查以确保用户只能访问他们被允许访问的资源。
   - **数据保护策略：**
      - 对静态和传输中的敏感数据进行加密。
      - 使用安全存储机制存储敏感数据。
   - **安全 API 通信：**
      - 对所有 API 通信使用 HTTPS。
      - 验证 API 响应以确保它们有效且不恶意。

## 5. 测试方法：

   - **单元测试策略：**
      - 使用 Jest 或 Mocha 等测试框架为单个组件和实用函数编写单元测试。
      - 模拟外部依赖项以隔离被测试的代码。
   - **集成测试：**
      - 使用 Cypress 或 Playwright 等测试框架编写集成测试，验证不同组件或模块之间的交互。
      - 测试与 API 和其他外部服务的集成。
   - **端到端测试：**
      - 使用 Cypress 或 Playwright 等测试框架编写端到端测试，模拟用户与应用程序的交互。
      - 从开始到结束测试整个应用程序流程。
   - **测试组织：**
      - 将测试组织到镜像应用程序目录结构的目录中。
      - 为测试文件和测试用例使用描述性名称。
   - **模拟和存根：**
      - 使用 Jest 的 `jest.fn()` 或 Sinon.js 等模拟库模拟外部依赖项。
      - 使用存根将复杂或缓慢的依赖项替换为更简单的实现以进行测试。

## 6. 常见陷阱和注意事项：

   - **开发人员常犯的错误：**
      - **错误的响应性使用：** 未能理解 Svelte 的响应性系统如何工作可能导致意外行为。
      - **过度依赖 `$:`：** 尽管响应式声明很强大，但过度使用它们会使代码更难阅读和调试。考虑常规变量或函数是否更合适。
      - **直接修改属性：** 在组件内直接修改属性可能导致意外副作用。
   - **需要注意的边缘情况：**
      - **过渡和动画行为：** 理解过渡和动画如何与组件更新交互对于创建流畅的用户体验很重要。
      - **服务器端渲染（SSR）考虑：** 使用 SvelteKit 时，要注意客户端和服务器端执行环境之间的差异。
   - **版本特定问题：**
      - 升级到新版本时查阅 Svelte 更新日志和迁移指南以避免兼容性问题。
   - **兼容性问题：**
      - 确保您的代码与目标浏览器和设备兼容。
      - 如有必要，使用 polyfills 或转译器支持较旧的浏览器。
   - **调试策略：**
      - 使用 Svelte Devtools 浏览器扩展检查组件状态和响应性。
      - 使用 `console.log` 或 `debugger` 语句调试代码执行。
      - 使用 SvelteKit 的内置错误处理和日志功能。

## 7. 工具和环境：

   - **推荐的开发工具：**
      - **带有 Svelte 扩展的 VS Code：** 提供语法高亮、代码补全和其他有用功能。
      - **Svelte Devtools：** 用于检查 Svelte 组件状态和响应性的浏览器扩展。
      - **ESLint 和 Prettier：** 用于代码检查和格式化。
   - **构建配置：**
      - 使用 Vite 或 Rollup 等构建工具为生产打包您的 Svelte 代码。
      - 配置构建工具执行压缩和树摇等优化。
   - **代码检查和格式化：**
      - 使用带有 `eslint-plugin-svelte3` 插件的 ESLint 检查您的 Svelte 代码。
      - 使用带有 `prettier-plugin-svelte` 插件的 Prettier 格式化您的 Svelte 代码。
   - **部署最佳实践：**
      - 将您的 Svelte 应用程序部署到 CDN 或 Netlify 或 Vercel 等无服务器平台。
      - 配置您的服务器使用适当的缓存标头提供应用程序的静态资源。
   - **CI/CD 集成：**
      - 使用 GitHub Actions 或 GitLab CI 等 CI/CD 平台自动化构建、测试和部署过程。
      - 在每次提交时运行测试和代码检查以确保代码质量。
