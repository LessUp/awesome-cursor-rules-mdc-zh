---
description: 此规则为 NestJS 最佳实践、编码标准和架构模式提供全面指导。旨在通过涵盖代码组织、安全、测试和其他重要方面，帮助开发人员构建可扩展、可维护和高性能的 NestJS 应用程序。
globs: "*.ts"
---
- **代码组织和结构：**
  - **目录结构：**
    - 采用反映应用程序领域或功能的模块化结构。常见方法包括将代码组织到模块、服务、控制器、DTO 和实体中，每个都在自己的目录中。
    - 示例：
      ```
      src/
      ├── app.module.ts
      ├── auth/
      │   ├── auth.module.ts
      │   ├── auth.controller.ts
      │   ├── auth.service.ts
      │   ├── strategies/
      │   │   └── jwt.strategy.ts
      │   ├── dtos/
      │   │   └── create-user.dto.ts
      │   └── entities/
      │       └── user.entity.ts
      ├── users/
      │   ├── users.module.ts
      │   ├── users.controller.ts
      │   ├── users.service.ts
      │   └── ...
      ├── core/
      │   ├── filters/
      │   │   └── http-exception.filter.ts
      │   ├── interceptors/
      │   │   └── logging.interceptor.ts
      │   └── ...
      └── main.ts
      ```
  - **文件命名约定：**
    - 使用描述性和一致的命名约定。根据文件角色添加前缀（例如，`user.controller.ts`、`auth.service.ts`、`create-user.dto.ts`）。
    - 类和接口使用 PascalCase（例如，`UserService`、`CreateUserDto`）。
    - 实例和变量使用 camelCase（例如，`userService`、`createUserDto`）。
  - **模块组织：**
    - 在模块内封装功能。每个模块应代表应用程序的不同部分并处理相关功能。
    - 模块应导入必要的依赖项并导出其他模块需要的组件。
    - 使用 `forRoot` 和 `forFeature` 方法分别用于配置和功能模块，特别是在处理数据库连接或其他共享资源时。
  - **组件架构：**
    - 遵循 SOLID 原则设计组件。每个组件（控制器、服务等）应有单一职责。
    - 使用依赖注入管理组件之间的依赖关系，使它们更可测试和可维护。
    - 控制器应处理请求路由和验证，服务应实现业务逻辑，实体应表示数据模型。
  - **代码分割策略：**
    - 对于大型应用程序，考虑使用功能模块或延迟加载模块将模块分割为更小、更易管理的块。
    - 使用动态导入和延迟加载改善初始加载时间并减少包大小。

- **常见模式和反模式：**
  - **设计模式：**
    - **依赖注入：** 使用 NestJS 的内置依赖注入容器管理依赖关系并促进松耦合。
    - **仓储模式：** 将数据访问逻辑抽象到仓储中，以解耦服务与特定数据库实现。
    - **工作单元：** 使用工作单元模式管理跨多个仓储的事务。
    - **CQRS（命令查询职责分离）：** 对于复杂应用程序，考虑使用 CQRS 分离读写操作，提高性能和可扩展性。
  - **推荐方法：**
    - 使用 DTO（数据传输对象）在层之间进行数据验证和转换。
    - 实施全局异常过滤器在整个应用程序中一致地处理错误。
    - 使用拦截器处理日志记录、缓存和其他横切关注点。
    - 利用管道进行请求验证和数据转换。
    - 对非阻塞 I/O 操作使用异步操作（`async/await`）。
  - **反模式：**
    - **紧耦合：** 避免创建难以测试和维护的紧耦合组件。使用依赖注入和接口促进松耦合。
    - **上帝类：** 避免创建职责过多的类。将大型类分解为更小、更易管理的组件。
    - **忽略错误：** 始终使用 try-catch 块、异常过滤器和日志记录正确处理错误。永远不要忽略错误或吞噬异常。
    - **硬编码配置：** 避免在代码中直接硬编码配置值。使用环境变量或配置文件管理设置。
  - **状态管理：**
    - 对于简单应用程序，使用服务管理应用程序状态。
    - 对于更复杂的应用程序，考虑使用 Redux 或 NgRx 等状态管理库（尽管这在后端不太常见）。
    - 避免在客户端状态中存储敏感数据。在服务器上安全存储。
  - **错误处理：**
    - 实施全局异常过滤器捕获未处理的异常并向客户端返回适当的错误响应。
    - 使用自定义异常表示应用程序中的特定错误条件。
    - 记录具有足够详细信息的错误以便于调试。
    - 返回具有适当 HTTP 状态码的一致错误响应。

- **性能考虑：**
  - **优化技术：**
    - 使用缓存减少数据库负载并改善响应时间。NestJS 提供使用拦截器的内置缓存支持。
    - 通过使用索引、避免 N+1 查询和使用高效的数据检索方法优化数据库查询。
    - 使用连接池减少建立数据库连接的开销。
    - 分析应用程序以识别性能瓶颈并相应优化。
  - **内存管理：**
    - 通过正确管理资源和释放未使用的对象避免内存泄漏。
    - 使用流处理大文件或数据流。
    - 使用对象池重用频繁创建的对象。
  - **渲染优化（服务器端渲染）：**
    - 不直接适用于 NestJS，因为它主要是后端框架。但是，如果使用 SSR，通过缓存渲染页面和使用高效的模板引擎优化渲染性能。
  - **包大小优化：**
    - 使用树摇从包中删除未使用的代码。
    - 压缩和压缩代码以减少包大小。
    - 使用代码分割仅为每个路由或模块加载必要的代码。
  - **延迟加载：**
    - 使用延迟加载按需加载模块或功能，改善初始加载时间。
    - 实施代码分割创建可独立加载的更小包。

- **安全最佳实践：**
  - **常见漏洞：**
    - **SQL 注入：** 通过使用参数化查询或自动转义用户输入的 ORM 防止 SQL 注入。
    - **跨站脚本（XSS）：** 通过清理用户输入和编码输出防止 XSS。
    - **跨站请求伪造（CSRF）：** 使用令牌或其他机制实施 CSRF 保护。
    - **身份验证和授权缺陷：** 通过使用强密码、多因素身份验证和基于角色的访问控制保护身份验证和授权。
    - **不安全的直接对象引用（IDOR）：** 通过在授予访问权限之前验证用户对资源的访问来防止 IDOR。
  - **输入验证：**
    - 验证所有用户输入以防止恶意数据进入系统。使用 DTO 和验证管道强制执行输入约束。
    - 清理用户输入以删除或转义潜在有害字符。
    - 验证文件上传以防止上传恶意文件。
  - **身份验证和授权：**
    - 使用 JWT（JSON Web 令牌）进行身份验证和授权。
    - 实施基于角色的访问控制（RBAC）根据用户角色限制对资源的访问。
    - 使用安全密码哈希算法（例如，bcrypt）安全存储密码。
    - 实施速率限制防止暴力攻击。
  - **数据保护：**
    - 对静态和传输中的敏感数据进行加密。
    - 使用 HTTPS 加密客户端和服务器之间的通信。
    - 使用环境变量或机密管理系统安全存储机密。
  - **安全 API 通信：**
    - 使用 API 密钥或 OAuth 2.0 进行 API 身份验证和授权。
    - 实施请求验证和速率限制保护 API 免受滥用。
    - 使用安全 API 网关管理 API 流量并强制执行安全策略。

- **测试方法：**
  - **单元测试：**
    - 为单个组件（服务、控制器等）编写单元测试以独立验证其功能。
    - 使用模拟和存根将组件与其依赖项隔离。
    - 遵循安排-执行-断言模式编写清晰简洁的单元测试。
  - **集成测试：**
    - 编写集成测试验证多个组件或模块之间的交互。
    - 测试应用程序与外部系统（例如，数据库、API）之间的集成。
  - **端到端测试：**
    - 编写端到端测试从用户角度验证应用程序的功能。
    - 使用 Puppeteer 或 Cypress 等工具自动化端到端测试。
  - **测试组织：**
    - 将测试组织到镜像应用程序目录结构的单独目录中。
    - 为测试文件和测试用例使用描述性名称。
  - **模拟和存根：**
    - 使用模拟框架（例如，Jest、Sinon.js）创建模拟对象和存根方法。
    - 使用依赖注入使组件易于测试。

- **常见陷阱和注意事项：**
  - **常见错误：**
    - **不使用 DTO 进行验证：** 始终使用 DTO 和验证管道确保数据完整性。
    - **忽略环境变量：** 使用环境变量进行配置以避免硬编码值。
    - **不正确处理异常：** 实施全局异常过滤器捕获未处理的异常并返回适当的错误响应。
    - **忽视安全漏洞：** 注意常见安全漏洞并采取措施缓解它们。
  - **边缘情况：**
    - **处理大文件上传：** 使用流和适当的缓冲技术高效处理大文件上传。
    - **处理并发请求：** 使用适当的锁定机制或事务管理安全处理并发请求。
  - **版本特定问题：**
    - 注意 NestJS 版本之间的破坏性变更并相应更新代码。
    - 查阅 NestJS 文档了解迁移指南和兼容性信息。
  - **兼容性问题：**
    - 确保与不同 Node.js 版本和操作系统的兼容性。
    - 在不同浏览器和设备上测试应用程序以确保跨平台兼容性。
  - **调试策略：**
    - 使用 NestJS 调试器逐步执行代码并检查变量。
    - 使用日志记录跟踪执行流程并识别错误。
    - 使用分析工具识别性能瓶颈。

- **工具和环境：**
  - **推荐的开发工具：**
    - **IDE：** 带有 NestJS 扩展的 Visual Studio Code。
    - **CLI：** Nest CLI 用于生成和管理 NestJS 项目。
    - **数据库：** PostgreSQL、MySQL、MongoDB 或其他兼容数据库。
    - **测试：** Jest、Supertest。
  - **构建配置：**
    - 使用 `tsconfig.json` 配置 TypeScript 编译器。
    - 使用 Webpack 或 Parcel 打包和优化应用程序。
  - **代码检查和格式化：**
    - 使用 ESLint 和 Prettier 强制执行代码风格和格式化规则。
    - 配置预提交钩子在提交前自动检查和格式化代码。
  - **部署：**
    - 部署到 Heroku、AWS、Google Cloud 或 Azure 等平台。
    - 使用 Docker 容器化应用程序并简化部署。
  - **CI/CD 集成：**
    - 与 CI/CD 管道（例如，Jenkins、Travis CI、GitHub Actions）集成以自动化测试和部署。
    - 为不同环境（开发、暂存、生产）使用环境特定的配置文件。
