---
description: 强制执行 Java 开发的最佳实践，涵盖代码风格、性能、安全和测试。提供编写清洁、可维护和高效 Java 代码的指导。
globs: "*.java"
---
- # Java 最佳实践

  本文档概述了 Java 开发的综合最佳实践，涵盖代码组织、常见模式、性能考虑、安全、测试、常见陷阱和工具。遵循这些指南将帮助您编写清洁、可维护、高效和安全的 Java 代码。

- ## 1. 代码组织和结构

  - ### 1.1 目录结构

    - **Maven 标准布局：** 对大多数项目使用标准 Maven 目录结构。这提供了一致且可预测的布局，易于其他开发人员和工具理解。

      src/
        main/
          java/
            com/example/  <- 您的包结构从这里开始
          resources/
        test/
          java/
            com/example/
          resources/
        pom.xml  <- Maven 项目文件

    - **Gradle 布局：** Gradle 支持 Maven 布局并提供其他配置源目录的方法。选择最适合您项目需求的布局。

    - **按功能打包：** 按功能而不是按层（例如，控制器、服务、仓储）组织包。这提高了内聚性并减少了功能之间的依赖关系。

      src/
        main/
          java/
            com/example/
              user/
                UserController.java
                UserService.java
                UserRepository.java
              product/
                ProductController.java
                ProductService.java
                ProductRepository.java

    - **模块化：** 对于大型项目，考虑使用 Java 模块（Jigsaw，在 Java 9 中引入）来改善封装并减少依赖关系。

  - ### 1.2 文件命名约定

    - **类和接口：** 使用 `PascalCase`（例如，`UserController`、`UserService`）。
    - **方法和变量：** 使用 `camelCase`（例如，`getUserById`、`userName`）。
    - **常量：** 使用 `UPPER_SNAKE_CASE`（例如，`MAX_RETRIES`、`DEFAULT_TIMEOUT`）。
    - **包：** 使用全小写（例如，`com.example.user`）。
    - **避免缩写：** 使用有意义和描述性的名称。

  - ### 1.3 模块组织

    - **`module-info.java`：** 使用 `module-info.java` 定义模块依赖关系和导出包。这允许强封装和对内部 API 的受控访问。
    - **显式依赖关系：** 在 `module-info.java` 中显式声明所有模块依赖关系。避免依赖传递依赖关系。
    - **最小化导出：** 仅导出用于公共使用的包。保持内部包对其他模块隐藏。

  - ### 1.4 组件架构

    - **依赖注入：** 使用依赖注入（DI）管理组件依赖关系。Spring 和 Guice 等框架简化了 DI。
    - **控制反转（IoC）：** 应用 IoC 解耦组件并提高可测试性。
    - **分层架构：** 将应用程序结构化为层（例如，表示层、业务逻辑层、数据访问层）。这促进了关注点分离和可维护性。
    - **微服务：** 对于大型、复杂的应用程序，考虑微服务架构。这允许独立开发、部署和扩展单个服务。

  - ### 1.5 代码分割

    - **功能开关：** 使用功能开关在运行时启用或禁用功能。这允许增量部署和测试新功能。
    - **动态加载：** 使用动态类加载按需加载模块或组件。这可以减少应用程序的初始启动时间和内存占用。
    - **条件编译：** 使用条件编译（例如，使用 Maven 配置文件）根据环境包含或排除代码。这允许为开发、测试和生产使用不同的配置。

- ## 2. 常见模式和反模式

  - ### 2.1 设计模式

    - **单例：** 谨慎使用单例模式，仅在真正需要类的单个实例时使用。考虑依赖注入作为替代方案。
    - **工厂：** 使用工厂模式创建对象而不指定其具体类。这促进了松耦合并允许轻松替换不同的实现。
    - **策略：** 使用策略模式封装不同的算法或行为。这允许您在运行时切换算法。
    - **观察者：** 使用观察者模式定义对象之间的一对多依赖关系。这允许松耦合并轻松添加新观察者。
    - **模板方法：** 使用模板方法模式在基类中定义算法的骨架，允许子类覆盖特定步骤而不改变整体结构。
    - **构建器：** 使用构建器模式构造具有许多可选参数的复杂对象。这提高了可读性并减少了错误风险。

  - ### 2.2 推荐方法

    - **资源管理：** 始终使用 try-with-resources 确保正确的资源管理（例如，关闭流、连接）。这防止资源泄漏。
      java
      try (FileInputStream fis = new FileInputStream("file.txt")) {
          // 使用文件输入流
      }

    - **字符串连接：** 使用 `StringBuilder` 或 `StringBuffer` 进行字符串连接，特别是在循环中。避免使用 `+` 操作符进行重复字符串连接。
      java
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < 100; i++) {
          sb.append(i);
      }
      String result = sb.toString();

    - **集合：** 优先使用 Java 集合而不是数组，因为它们的灵活性和实用性。使用泛型确保类型安全。

  - ### 2.3 反模式和代码异味

    - **上帝类：** 避免创建做太多事情的大类。将大类分解为更小、更易管理的组件。
    - **长方法：** 避免创建长方法。将长方法分解为更小、更专注的方法。
    - **散弹手术：** 避免在多个类中进行许多小更改。这表明缺乏内聚性，可能使代码难以维护。
    - **数据团块：** 避免在多个方法中一起传递相同的数据项组。创建一个类来封装数据项。
    - **基本类型偏执：** 避免过度使用基本类型。创建值对象来表示领域概念。
    - **Switch 语句：** 限制 switch 语句的使用，特别是具有大量 case 的语句。考虑使用策略模式的多态性。
    - **空 Catch 块：** 避免空 catch 块。始终适当处理异常，要么记录它们，要么重新抛出它们，要么采取纠正措施。

  - ### 2.4 状态管理

    - **不可变性：** 尽可能优先使用不可变对象。不可变对象是线程安全的，更容易推理。
    - **无状态服务：** 设计服务为无状态。这提高了可扩展性并简化了测试。
    - **会话管理：** 使用会话管理框架（例如，Spring Session）在 Web 应用程序中管理用户会话。

  - ### 2.5 错误处理

    - **异常用于异常情况：** 仅在异常情况下使用异常，而不是用于正常控制流。
    - **特定异常类型：** 捕获特定异常类型而不是通用 `Exception`。这允许您以不同方式处理不同类型的错误。
    - **日志记录：** 记录异常并提供足够的上下文以帮助调试。包括堆栈跟踪和任何相关数据。
    - **自定义异常：** 创建自定义异常类型来表示应用程序特定的错误。
    - **不要吞噬异常：** 永远不要在不记录或处理异常的情况下吞噬异常。这隐藏了异常，使调试变得更加困难。

- ## 3. 性能考虑

  - ### 3.1 优化技术

    - **缓存：** 使用缓存将频繁访问的数据存储在内存中。Caffeine 和 Guava Cache 等框架提供高效的缓存实现。
    - **连接池：** 使用连接池重用数据库连接。这减少了创建和关闭连接的开销。
    - **高效算法：** 为特定任务选择适当的算法。考虑不同算法的时间和空间复杂度。
    - **延迟初始化：** 使用延迟初始化推迟对象的创建，直到实际需要它们。
    - **最小化对象创建：** 减少不必要的对象创建。尽可能使用对象池或重用现有对象。

  - ### 3.2 内存管理

    - **垃圾收集：** 了解 Java 垃圾收集器的工作原理。避免创建快速丢弃的对象，因为这会给垃圾收集器带来压力。
    - **内存分析：** 使用内存分析工具识别内存泄漏并优化内存使用。
    - **大对象：** 处理大对象时要小心。它们可能导致碎片化并增加垃圾收集时间。

  - ### 3.3 渲染优化（如果适用）

    - **缓冲：** 在渲染大量数据时使用缓冲减少 I/O 操作次数。
    - **压缩：** 使用压缩减少渲染数据的大小。

  - ### 3.4 包大小优化（如果适用）

    - **代码压缩：** 使用代码压缩减少代码库的大小。
    - **死代码消除：** 删除未使用的代码以减少包大小。

  - ### 3.5 延迟加载

    - **按需加载：** 仅在需要时加载资源或组件。
    - **虚拟代理：** 使用虚拟代理延迟加载重资源，直到访问它。

- ## 4. 安全最佳实践

  - ### 4.1 常见漏洞

    - **SQL 注入：** 通过使用参数化查询或预处理语句防止 SQL 注入。永远不要将用户输入直接连接到 SQL 查询中。
    - **跨站脚本（XSS）：** 通过在网页中显示用户输入之前对其进行编码来防止 XSS。
    - **跨站请求伪造（CSRF）：** 通过使用反 CSRF 令牌防止 CSRF。
    - **身份验证和授权问题：** 实施适当的身份验证和授权机制保护敏感资源。
    - **拒绝服务（DoS）：** 通过限制请求速率和实施速率限制防止 DoS 攻击。
    - **不安全的反序列化：** 通过避免反序列化不受信任的数据或使用安全反序列化方法防止不安全的反序列化。
    - **依赖项漏洞：** 使用 OWASP Dependency-Check 等工具识别和缓解第三方库中的漏洞。

  - ### 4.2 输入验证

    - **白名单：** 使用白名单根据允许值列表验证输入。避免黑名单，因为很难预测所有可能的恶意输入。
    - **正则表达式：** 使用正则表达式验证输入模式（例如，电子邮件地址、电话号码）。
    - **长度限制：** 对输入字段强制执行长度限制以防止缓冲区溢出。
    - **编码：** 编码用户输入以防止 XSS 攻击。

  - ### 4.3 身份验证和授权

    - **强密码：** 强制执行强密码策略（例如，最小长度、复杂性）。
    - **哈希：** 使用强哈希算法（例如，bcrypt、Argon2）和盐对密码进行哈希。
    - **双因素身份验证（2FA）：** 实施 2FA 提供额外的安全层。
    - **基于角色的访问控制（RBAC）：** 使用 RBAC 根据用户角色控制对资源的访问。
    - **OAuth 2.0：** 使用 OAuth 2.0 进行委托授权。

  - ### 4.4 数据保护

    - **加密：** 对静态和传输中的敏感数据进行加密。
    - **数据掩码：** 在日志和错误消息中掩码敏感数据。
    - **访问控制：** 仅限授权用户访问敏感数据。

  - ### 4.5 安全 API 通信

    - **HTTPS：** 对所有 API 通信使用 HTTPS。
    - **TLS/SSL：** 正确配置 TLS/SSL 以确保安全通信。
    - **API 密钥：** 使用 API 密钥验证 API 客户端。
    - **速率限制：** 实施速率限制防止滥用您的 API。
    - **输入验证：** 验证 API 的所有输入以防止注入攻击。

- ## 5. 测试方法

  - ### 5.1 单元测试

    - **JUnit：** 使用 JUnit 进行单元测试。
    - **Mockito：** 使用 Mockito 模拟依赖项。
    - **安排-执行-断言：** 在单元测试中遵循安排-执行-断言模式。
    - **测试覆盖率：** 追求高测试覆盖率。
    - **独立测试：** 编写独立测试，使一个测试的失败不会影响另一个测试。

  - ### 5.2 集成测试

    - **Testcontainers：** 使用 Testcontainers 为集成测试创建轻量级、一次性的数据库和其他服务实例。
    - **Spring Boot Test：** 使用 Spring Boot 的测试支持进行 Spring 应用程序的集成测试。

  - ### 5.3 端到端测试

    - **Selenium：** 使用 Selenium 进行 Web 应用程序的端到端测试。
    - **Cypress：** 考虑 Cypress 作为 Selenium 的端到端测试替代方案。

  - ### 5.4 测试组织

    - **测试目录：** 将测试放在单独的 `test` 目录中。
    - **命名约定：** 为测试使用清晰的命名约定（例如，`UserServiceTest`）。
    - **测试套件：** 将相关测试分组到测试套件中。

  - ### 5.5 模拟和存根

    - **Mockito：** 使用 Mockito 为测试创建模拟和存根。
    - **验证交互：** 验证您的代码是否按预期与依赖项交互。
    - **避免过度模拟：** 避免模拟太多依赖项。专注于模拟对测试至关重要的依赖项。

- ## 6. 常见陷阱和注意事项

  - ### 6.1 常见错误

    - **NullPointerExceptions：** 小心处理空值以避免 `NullPointerException`。
    - **资源泄漏：** 确保所有资源都正确关闭以避免资源泄漏。
    - **线程安全问题：** 在编写多线程代码时注意线程安全问题。
    - **忽略异常：** 永远不要在不记录或处理异常的情况下忽略异常。这隐藏了异常，使调试变得更加困难。

  - ### 6.2 边缘情况

    - **边界条件：** 测试边界条件以确保您的代码正确处理边缘情况。
    - **空集合：** 优雅地处理空集合。
    - **无效输入：** 验证输入以确保它在预期范围内。

  - ### 6.3 版本特定问题

    - **已弃用的 API：** 注意已弃用的 API 并避免使用它们。
    - **兼容性问题：** 使用不同版本的 Java 测试您的代码以确保兼容性。

  - ### 6.4 兼容性问题

    - **JVM 兼容性：** 确保您的代码与不同的 JVM 实现兼容。
    - **库兼容性：** 注意不同库之间的兼容性问题。

  - ### 6.5 调试策略

    - **日志记录：** 使用日志记录跟踪代码的执行并识别错误。
    - **调试工具：** 使用调试工具逐步执行代码并检查变量。
    - **远程调试：** 使用远程调试来调试在远程服务器上运行的应用程序。
    - **JVM 分析器：** 使用 JProfiler 或 VisualVM 等分析器识别性能瓶颈和内存泄漏。

- ## 7. 工具和环境

  - ### 7.1 推荐工具

    - **IntelliJ IDEA：** 功能强大的 Java 开发 IDE，具有出色的代码补全、重构和调试支持。
    - **Eclipse：** 另一个流行的 Java 开发 IDE。
    - **Maven：** 用于管理依赖项、构建和部署 Java 项目的构建自动化工具。
    - **Gradle：** 提供比 Maven 更多灵活性和控制的构建自动化工具。

  - ### 7.2 构建配置

    - **依赖管理：** 使用 Maven 或 Gradle 管理依赖项。
    - **版本控制：** 使用版本控制（例如，Git）跟踪代码库的更改。
    - **构建配置文件：** 使用构建配置文件为不同环境配置不同的构建。

  - ### 7.3 代码检查和格式化

    - **Checkstyle：** 使用 Checkstyle 强制执行编码标准。
    - **PMD：** 使用 PMD 查找潜在错误和代码异味。
    - **SpotBugs：** 使用 SpotBugs 查找潜在错误。
    - **格式化器：** 使用自动代码格式化工具，如 IntelliJ 的内置格式化器或 `google-java-format` 等插件以保持一致性。

  - ### 7.4 部署

    - **Docker：** 使用 Docker 容器化您的应用程序。
    - **Kubernetes：** 使用 Kubernetes 编排您的容器。
    - **云平台：** 将应用程序部署到 AWS、Azure 或 Google Cloud 等云平台。

  - ### 7.5 CI/CD

    - **Jenkins：** 使用 Jenkins 进行持续集成和持续交付。
    - **GitHub Actions：** 使用 GitHub Actions 进行 CI/CD。
    - **GitLab CI：** 使用 GitLab CI 进行 CI/CD。
    - **自动化测试：** 在 CI/CD 管道中自动化单元测试、集成测试和端到端测试。

通过遵循这些最佳实践，您可以提高 Java 代码的质量、可维护性和性能。记住要根据您的特定项目要求和团队偏好调整这些指南。
