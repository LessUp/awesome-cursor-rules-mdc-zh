---
description: 此规则提供开发强大、可维护和高性能 Express.js 应用程序最佳实践的综合指导，涵盖从代码组织和安全到测试和部署的各个方面。
globs: "*.js"
---
# Express.js 最佳实践

本文档概述了开发 Express.js 应用程序的最佳实践，以确保代码质量、可维护性、性能和安全性。

## 1. 代码组织和结构

### 目录结构最佳实践

- **模块化结构：** 根据功能将应用程序组织成逻辑模块（例如，`controllers`、`models`、`routes`、`middleware`、`services`）。
- **配置：** 为不同环境（开发、生产、测试）分离配置文件。
- **公共资源：** 将静态资源（CSS、JavaScript、图像）保存在专用的 `public` 目录中。
- **视图：** 将模板文件存储在 `views` 目录中。使用 EJS 或 Pug 等模板引擎。
- **示例结构：**


  my-express-app/
  ├── controllers/
  │   ├── userController.js
  │   └── productController.js
  ├── models/
  │   ├── user.js
  │   └── product.js
  ├── routes/
  │   ├── userRoutes.js
  │   └── productRoutes.js
  ├── middleware/
  │   ├── authMiddleware.js
  │   └── errorMiddleware.js
  ├── services/
  │   ├── userService.js
  │   └── productService.js
  ├── config/
  │   ├── config.js
  │   └── db.js
  ├── views/
  │   ├── index.ejs
  │   └── user.ejs
  ├── public/
  │   ├── css/
  │   │   └── style.css
  │   ├── js/
  │   │   └── script.js
  │   └── images/
  ├── app.js         # 主应用程序文件
  ├── package.json
  └── .env           # 环境变量


### 文件命名约定

- **描述性名称：** 为文件和目录使用清晰和描述性的名称。
- **大小写约定：** JavaScript 文件和目录使用 camelCase。对于组件考虑使用 PascalCase。
- **路由文件：** 根据它们处理的资源命名路由文件（例如，`userRoutes.js`、`productRoutes.js`）。
- **控制器文件：** 根据它们处理的资源命名控制器文件（例如，`userController.js`、`productController.js`）。
- **模型文件：** 根据它们表示的数据模型命名模型文件（例如，`user.js`、`product.js`）。

### 模块组织

- **ES 模块：** 使用 ES 模块（`import`/`export`）实现模块化。
- **单一职责原则：** 每个模块应该有单一、明确定义的职责。
- **松耦合：** 最小化模块之间的依赖关系以提高可重用性和可测试性。

### 组件架构

- **可重用组件：** 将应用程序分解为可重用组件（例如，UI 组件、服务组件）。
- **关注点分离：** 将表示逻辑（视图）与业务逻辑（控制器/服务）分离。
- **组件组合：** 从更简单的组件组合复杂组件。

### 代码分割策略
- **基于路由的分割：** 根据应用程序路由分割代码以减少初始加载时间。使用动态导入（`import()`）按需加载模块。
- **基于组件的分割：** 根据组件分割代码，仅在需要时加载组件。

## 2. 常见模式和反模式

### Express 特定的设计模式

- **中间件模式：** 使用中间件函数处理请求处理、身份验证、日志记录等。
- **MVC 模式：** 实施模型-视图-控制器（MVC）模式以分离关注点并改善代码组织。
- **观察者模式：** 当需要通知多个对象状态变化时实施观察者模式。

### 常见任务的推荐方法

- **路由处理：** 使用 Express Router 在单独的模块中定义路由。
- **错误处理：** 使用自定义错误处理中间件优雅地捕获和处理错误。详见第 6 节。
- **数据验证：** 使用中间件在处理请求数据之前验证请求数据。
- **异步操作：** 使用 `async/await` 或 Promises 处理异步操作。

### 要避免的反模式和代码异味

- **上帝对象：** 避免创建处理太多职责的单一、庞大对象。
- **回调地狱：** 避免深度嵌套的回调；使用 Promises 或 `async/await` 代替。
- **忽略错误：** 始终正确处理错误而不是忽略它们。
- **全局变量：** 最小化全局变量的使用以避免命名冲突和意外行为。
- **硬编码机密：** 永远不要在代码中硬编码敏感信息（API 密钥、密码）。使用环境变量代替。

### 状态管理最佳实践

- **无状态控制器：** 保持控制器无状态以提高可扩展性和可测试性。
- **会话管理：** 使用会话管理中间件（例如，`express-session`）管理用户会话。
- **缓存：** 实施缓存策略（例如，Redis、Memcached）以提高性能。

### 错误处理模式

- **集中式错误处理：** 创建自定义错误处理中间件以捕获和处理来自应用程序不同部分的错误。
- **错误日志记录：** 将错误记录到文件或监控服务以进行调试和分析。
- **自定义错误对象：** 创建具有特定错误代码和消息的自定义错误对象。
- **优雅的错误消息：** 返回用户友好的错误消息而不是暴露内部错误。
- **示例错误处理中间件：**

  ```javascript
  // middleware/errorMiddleware.js
  const errorHandler = (err, req, res, next) => {
    console.error(err.stack);
    const statusCode = res.statusCode === 200 ? 500 : res.statusCode;
    res.status(statusCode);
    res.json({
      message: err.message,
      stack: process.env.NODE_ENV === 'production' ? null : err.stack,
    });
  };

  module.exports = errorHandler;
  ```

## 3. 性能考虑

### 优化技术

- **Gzip 压缩：** 使用 Gzip 压缩减少响应大小。
- **缓存：** 在不同级别（例如，浏览器缓存、服务器端缓存）实施缓存以减少服务器负载。
- **连接池：** 对数据库连接使用连接池以提高性能。
- **负载均衡：** 使用负载均衡器在多个服务器之间分配流量。

### 内存管理

- **避免内存泄漏：** 注意内存泄漏，特别是在处理大型数据集或长时间运行的进程时。使用 `memwatch` 等工具进行分析。
- **垃圾收集：** 了解 Node.js 中垃圾收集的工作原理并相应优化代码。
- **流：** 使用流处理大文件或数据流以避免将整个数据加载到内存中。

### 渲染优化

- **模板缓存：** 在模板引擎中启用模板缓存以提高渲染性能。
- **压缩资源：** 压缩 CSS 和 JavaScript 文件以减少其大小。
- **延迟加载图像：** 延迟加载图像以改善初始页面加载时间。

### 包大小优化

- **树摇：** 使用树摇从包中删除未使用的代码。
- **代码分割：** 将代码分割为更小的块以减少初始包的大小。
- **依赖分析：** 分析依赖项以识别和删除不必要的包。

### 延迟加载策略

- **延迟加载模块：** 使用动态导入（`import()`）仅在需要时加载模块。
- **延迟加载图像和其他资源：** 对页面上不立即可见的图像和其他资源使用延迟加载。

## 4. 安全最佳实践

### 常见漏洞及其预防方法

- **跨站脚本（XSS）：** 通过清理用户输入和编码输出来防止 XSS 攻击。
- **跨站请求伪造（CSRF）：** 通过使用 CSRF 令牌防止 CSRF 攻击。
- **SQL 注入：** 使用参数化查询或 ORM 防止 SQL 注入攻击。
- **NoSQL 注入：** 清理用户输入并避免从字符串构造查询以防止 NoSQL 注入攻击。
- **命令注入：** 避免基于用户输入执行 shell 命令。如有必要，清理输入并使用适当的转义。
- **拒绝服务（DoS）：** 实施速率限制和其他措施防止 DoS 攻击。
- **中间人（MitM）：** 使用 HTTPS 加密客户端和服务器之间的通信并防止 MitM 攻击。
- **HTTP 参数污染（HPP）：** 避免在请求中多次使用相同参数以防止 HPP 攻击。

### 输入验证

- **服务器端验证：** 即使有客户端验证，也要始终在服务器端验证用户输入。
- **数据清理：** 清理用户输入以删除潜在有害字符或代码。
- **模式验证：** 使用模式验证库（例如，Joi、express-validator）根据预定义模式验证请求数据。

### 身份验证和授权模式

- **身份验证：** 使用安全的身份验证机制（例如，JWT、OAuth）验证用户身份。
- **授权：** 实施基于角色的访问控制（RBAC）或基于属性的访问控制（ABAC）控制对资源的访问。
- **安全密码存储：** 使用强哈希算法（例如，bcrypt）安全存储用户密码。
- **多因素身份验证（MFA）：** 实施 MFA 添加额外的安全层。

### 数据保护策略

- **加密：** 对静态和传输中的敏感数据进行加密。
- **数据掩码：** 在日志和其他输出中掩码敏感数据。
- **访问控制：** 限制对敏感数据的访问仅限于授权用户和进程。

### 安全 API 通信

- **HTTPS：** 对所有 API 通信使用 HTTPS。
- **API 密钥：** 使用 API 密钥验证客户端。
- **速率限制：** 实施速率限制防止滥用和 DoS 攻击。
- **输入验证：** 验证所有输入数据以防止注入攻击。
- **输出编码：** 编码所有输出数据以防止 XSS 攻击。

## 5. 测试方法

### 单元测试策略

- **测试驱动开发（TDD）：** 在编写实际代码之前编写单元测试。
- **测试单个模块：** 独立测试单个模块以确保它们正常工作。
- **模拟依赖项：** 模拟外部依赖项（例如，数据库、API）以隔离被测试的模块。

### 集成测试

- **测试模块之间的交互：** 测试不同模块之间的交互以确保它们正确协作。
- **测试 API 端点：** 测试 API 端点以确保它们返回预期结果。

### 端到端测试

- **测试整个应用程序流程：** 从开始到结束测试整个应用程序流程。
- **模拟用户交互：** 模拟用户交互以确保应用程序按预期行为。

### 测试组织

- **单独的测试文件：** 为每个模块或组件创建单独的测试文件。
- **描述性测试名称：** 为测试用例使用清晰和描述性的名称。
- **安排-执行-断言模式：** 在测试中遵循安排-执行-断言模式。

### 模拟和存根

- **使用模拟库：** 使用模拟库（例如，Jest、Sinon）创建模拟和存根。
- **模拟外部依赖项：** 模拟外部依赖项以隔离被测试的模块。
- **存根函数调用：** 存根函数调用以控制依赖项的行为。

## 6. 常见陷阱和注意事项

### 开发人员常犯的错误

- **不正确处理错误：** 始终正确处理错误以防止意外行为。
- **忽略安全漏洞：** 了解常见安全漏洞并采取措施防止它们。
- **不明智地使用中间件：** 明智地使用中间件处理身份验证、日志记录和错误处理等常见任务。
- **过度工程化：** 通过保持代码简单和专注来避免过度工程化。

### 需要注意的边缘情况

- **处理大文件上传：** 使用流或中间件库处理大文件上传以防止内存问题。
- **处理时区：** 在处理日期和时间时注意时区问题。
- **处理 Unicode 字符：** 正确处理 Unicode 字符以防止编码问题。
- **处理并发请求：** 实施并发控制机制以安全处理并发请求。

### 版本特定问题

- **已弃用的功能：** 了解已弃用的功能并使用推荐的替代方案。
- **破坏性变更：** 在升级到新版本的 Express.js 时注意破坏性变更。

### 兼容性问题

- **浏览器兼容性：** 在不同浏览器中测试应用程序以确保其正常工作。
- **操作系统兼容性：** 在不同操作系统上测试应用程序以确保其正常工作。
- **Node.js 版本兼容性：** 确保应用程序与支持的 Node.js 版本兼容。

### 调试策略

- **使用调试工具：** 使用调试工具（例如，Node.js Inspector、Chrome DevTools）调试代码。
- **日志语句：** 使用日志语句跟踪执行流程并识别问题。
- **错误消息：** 仔细阅读错误消息以了解错误原因。

## 7. 工具和环境

### 推荐的开发工具

- **IDE：** 使用良好的 IDE，如 VS Code、WebStorm 或 Sublime Text。
- **调试器：** 使用调试器逐步执行代码并识别问题。
- **代码检查器：** 使用代码检查器（例如，ESLint）强制执行编码标准。
- **格式化器：** 使用格式化器（例如，Prettier）自动格式化代码。

### 构建配置

- **使用构建工具：** 使用构建工具（例如，Webpack、Parcel）打包和优化代码。
- **配置构建脚本：** 在 `package.json` 文件中配置构建脚本以自动化构建过程。
- **使用环境变量：** 使用环境变量为不同环境配置应用程序。

### 代码检查和格式化

- **使用 ESLint：** 使用 ESLint 强制执行编码标准并识别潜在问题。
- **使用 Prettier：** 使用 Prettier 自动格式化代码。
- **配置编辑器集成：** 配置编辑器在保存时自动运行 ESLint 和 Prettier。

### 部署最佳实践

- **使用进程管理器：** 使用进程管理器（例如，PM2、Forever）在生产中保持应用程序运行。
- **使用反向代理：** 使用反向代理（例如，Nginx、Apache）处理传入请求并将其转发到应用程序。
- **使用负载均衡器：** 使用负载均衡器在多个服务器之间分配流量。
- **使用 HTTPS：** 使用 HTTPS 加密客户端和服务器之间的通信。
- **监控应用程序：** 监控应用程序以识别和解决问题。

### CI/CD 集成

- **使用 CI/CD 管道：** 使用 CI/CD 管道（例如，Jenkins、Travis CI、CircleCI、GitHub Actions）自动化构建、测试和部署过程。
- **自动运行测试：** 配置 CI/CD 管道在每次提交时自动运行测试。
- **自动化部署：** 自动化部署过程以减少错误风险。
