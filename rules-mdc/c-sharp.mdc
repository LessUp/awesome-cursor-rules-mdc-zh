---
description: 本规范文件提供了 C# 最佳实践、编码标准和常见模式的综合指南，用于编写可维护、高性能和安全的代码。
globs: "*.cs"
---
# C# 最佳实践和编码标准

本文档提供了 C# 最佳实践、编码标准和常见模式的综合指南，用于编写可维护、高性能和安全的代码。它涵盖了 C# 开发的各个方面，包括代码组织、常见模式、性能考虑、安全最佳实践、测试方法、常见陷阱和工具。

**库信息：**
- 名称：c-sharp
- 标签：language, microsoft, dotnet, backend

## 1. 代码组织和结构

良好组织的代码库对于可维护性、可扩展性和协作至关重要。以下是组织 C# 代码的一些最佳实践：

### 1.1. 目录结构最佳实践

* **项目根目录：** 包含解决方案文件 (.sln) 和项目目录。
* **项目目录：** 包含项目文件 (.csproj)、源代码和其他项目相关文件。
    * `src/`：包含主要源代码。
        * `Models/`：数据模型和 DTO（数据传输对象）。
        * `Services/`：业务逻辑和服务类。
        * `Controllers/`：API 控制器（如果适用）。
        * `Repositories/`：数据访问逻辑。
        * `Utilities/`：辅助类和工具函数。
        * `Exceptions/`：自定义异常定义。
        * `Interfaces/`：抽象的接口定义。
        * `Configuration/`：配置相关类。
    * `tests/`：包含单元测试、集成测试和端到端测试。
    * `docs/`：项目文档。
    * `build/`：构建脚本和配置文件。
    * `Properties/`：程序集信息和项目设置。

示例：

```
MyProject/
├── MyProject.sln
├── MyProject/
│   ├── MyProject.csproj
│   ├── src/
│   │   ├── Models/
│   │   ├── Services/
│   │   ├── Controllers/
│   │   ├── Repositories/
│   │   ├── Utilities/
│   │   ├── Exceptions/
│   │   ├── Interfaces/
│   │   └── Configuration/
│   ├── Properties/
│   │   └── AssemblyInfo.cs
│   └── appsettings.json
├── MyProject.Tests/
│   ├── MyProject.Tests.csproj
│   └── UnitTests/
└── README.md
```

### 1.2. 文件命名约定

* **类：** PascalCase（例如，`MyClass.cs`）
* **接口：** IPascalCase（例如，`IMyInterface.cs`）
* **枚举：** PascalCase（例如，`MyEnum.cs`）
* **结构：** PascalCase（例如，`MyStruct.cs`）
* **委托：** PascalCase（例如，`MyDelegate.cs`）
* **配置文件：** appsettings.json, config.xml
* **测试文件：** `MyClassTests.cs`

### 1.3. 模块组织

* **命名空间：** 使用命名空间对相关的类和接口进行分组。遵循一致的命名空间命名约定（例如，`CompanyName.ProjectName.ModuleName`）。
* **程序集：** 将大型项目分为多个程序集以改善构建时间、减少依赖关系并启用代码重用。在创建程序集时考虑功能或域边界。
* **NuGet 包：** 使用 NuGet 包管理依赖项并在项目间共享代码。

### 1.4. 组件架构

* **分层架构：** 将应用程序分为不同的层（例如，表示层、业务逻辑层、数据访问层）以促进关注点分离和可测试性。
* **微服务架构：** 对于大型和复杂的应用程序，考虑微服务架构，其中应用程序由小型、独立的服务组成。
* **依赖注入（DI）：** 使用 DI 管理组件之间的依赖关系，提高可测试性和可维护性。流行的 DI 容器包括 Autofac、Ninject 和 Microsoft.Extensions.DependencyInjection。

### 1.5. 代码分割策略

* **按功能：** 将与特定功能相关的代码分组到单独的模块或程序集中。
* **按层：** 基于架构层（例如，表示层、业务逻辑层、数据访问层）分离代码。
* **按职责：** 将类和方法分割为更小、更专注的工作单元。
* **部分类：** 使用部分类将大型类分割为多个文件以获得更好的组织（谨慎使用）。

## 2. 常见模式和反模式

理解常见的设计模式和反模式对于编写有效和可维护的 C# 代码至关重要。

### 2.1. 设计模式

* **单例模式：** 确保类只有一个实例并提供对它的全局访问点。
* **工厂模式：** 提供创建对象的接口而不指定其具体类。
* **抽象工厂模式：** 提供创建相关对象族的接口而不指定其具体类。
* **建造者模式：** 将复杂对象的构造与其表示分离，允许相同的构造过程创建不同的表示。
* **观察者模式：** 定义对象之间的一对多依赖关系，以便当一个对象改变状态时，所有依赖者都会被通知并自动更新。
* **策略模式：** 定义算法族，封装每一个，并使它们可互换。策略让算法独立于使用它的客户端而变化。
* **依赖注入（DI）：** 一种技术，其中一个对象（或静态方法）提供另一个对象的依赖项。这有助于解耦组件。
* **仓储模式：** 在域和数据映射层之间进行调解，就像内存中的域对象集合一样。
* **工作单元模式：** 维护受业务事务影响的对象列表并协调写出更改。
* **异步编程模式（TAP、EAP、APM）：** 使用 async/await 高效处理异步操作。

### 2.2. 常见任务的推荐方法

* **字符串操作：** 在循环中使用 `StringBuilder` 进行高效的字符串连接。
* **文件 I/O：** 使用 `using` 语句或 `try-finally` 块确保文件资源的正确释放。
* **数据访问：** 使用 Entity Framework Core 或 Dapper 等 ORM 简化数据访问。
* **异步操作：** 使用 `async` 和 `await` 进行非阻塞异步操作。
* **配置管理：** 使用 `Microsoft.Extensions.Configuration` 管理应用程序配置。
* **日志记录：** 使用 Serilog 或 NLog 等日志框架进行结构化日志记录。

### 2.3. 反模式和代码异味

* **上帝类：** 做太多事情并承担太多职责的类。
* **长方法：** 过长和复杂的方法。
* **特性嫉妒：** 访问另一个对象的数据比访问自己的数据更多的方法。
* **霰弹式手术：** 对代码一部分的更改需要对许多其他部分进行更改。
* **数据泥团：** 在多个地方一起出现的数据组。
* **基本类型偏执：** 使用基本类型而不是为域概念创建自定义类。
* **Switch 语句（而非多态）：** 使用大型 switch 语句而不是利用多态。
* **魔法数字/字符串：** 在代码中直接硬编码值而不是使用常量或配置设置。
* **忽略异常：** 捕获异常但不正确处理它们。
* **空的 Catch 块：** 捕获异常但什么都不做。
* **过度注释：** 编写从代码本身就很明显的过多注释。
* **死代码：** 永远不会执行的代码。

### 2.4. 状态管理最佳实践

* **无状态服务：** 尽可能设计无状态服务以提高可扩展性和可靠性。
* **会话状态：** 谨慎使用会话状态，仅在必要时使用。在 Web 应用程序中考虑使用分布式缓存进行会话状态。
* **缓存：** 使用缓存通过在内存中存储频繁访问的数据来提高性能。
* **Redux/Flux：** 对于复杂的 UI 应用程序，考虑使用 Redux 或 Flux 等状态管理库。
* **不可变数据结构：** 使用不可变数据结构简化状态管理并防止意外的副作用。

### 2.5. 错误处理模式

* **Try-Catch-Finally：** 使用 `try-catch-finally` 块处理异常并确保适当的资源清理。
* **异常过滤器：** 使用异常过滤器基于特定条件捕获特定异常。
* **自定义异常：** 为应用程序中的特定错误条件创建自定义异常类型。
* **记录异常：** 记录异常并提供足够的上下文以帮助调试。
* **优雅降级：** 优雅地处理错误并向用户提供信息性错误消息。
* **早抛出，晚捕获：** 尽早检测错误并在更高级别处理异常。

## 3. 性能考虑

优化 C# 代码的性能对于创建响应迅速和高效的应用程序至关重要。

### 3.1. 优化技术

* **避免装箱和拆箱：** 值类型的装箱和拆箱可能很昂贵。使用泛型避免装箱和拆箱。
* **适当时使用值类型：** 对于小型、不可变的数据结构，值类型（结构）可能比引用类型（类）更高效。
* **最小化对象分配：** 对象分配可能很昂贵。尽可能重用对象。
* **使用 `StringBuilder` 进行字符串连接：** `StringBuilder` 比使用 `+` 运算符的字符串连接更高效，特别是在循环中。
* **优化 LINQ 查询：** 谨慎使用 LINQ 并避免不必要的迭代或计算。考虑对大型集合使用 `AsParallel()` 进行并行处理（谨慎使用，因为并行性引入复杂性）。
* **使用异步编程：** 使用 `async` 和 `await` 避免阻塞主线程并提高响应性。
* **避免过度锁定：** 最小化锁的使用以防止争用并提高并发性。
* **使用延迟初始化：** 仅在需要时初始化对象以避免不必要的初始化开销。
* **分析您的代码：** 使用分析工具识别性能瓶颈并相应地优化。Visual Studio Profiler、dotTrace 和 PerfView 是不错的选择。

### 3.2. 内存管理考虑

* **垃圾回收：** 了解垃圾回收器的工作原理并避免创建过多垃圾。
* **释放资源：** 实现 `IDisposable` 接口并使用 `using` 语句确保资源的正确释放（例如，文件流、数据库连接）。
* **弱引用：** 使用弱引用持有对象的引用而不阻止它们被垃圾回收。
* **对象池：** 使用对象池重用对象并减少分配开销。
* **大对象堆（LOH）：** 了解大对象堆并避免不必要地分配大对象。

### 3.3. 渲染优化（如果适用）

* **UI 虚拟化：** 使用 UI 虚拟化仅渲染大型列表或网格中的可见项。
* **减少过度绘制：** 最小化像素相互重叠绘制的次数。
* **批量渲染：** 批量渲染操作以减少绘制调用次数。
* **使用硬件加速：** 使用硬件加速将渲染任务卸载到 GPU。

### 3.4. 包大小优化（如果适用）

* **树摇：** 从包中删除未使用的代码。
* **代码压缩：** 压缩代码以减少其大小。
* **代码压缩：** 使用 Gzip 或 Brotli 压缩代码。
* **图像优化：** 优化图像以在不牺牲质量的情况下减少其大小。

### 3.5. 延迟加载策略

* **延迟初始化：** 使用 `Lazy<T>` 仅在访问对象时初始化它们。
* **虚拟代理：** 使用虚拟代理仅在需要时加载相关数据。
* **显式加载：** 使用 Entity Framework Core 中的 `Include` 等方法显式加载相关数据。

## 4. 安全最佳实践

安全应该是 C# 开发中的主要关注点，以防止漏洞和攻击。

### 4.1. 常见漏洞和预防

* **SQL 注入：** 参数化数据库查询以防止 SQL 注入攻击。
* **跨站脚本（XSS）：** 编码用户输入以防止 XSS 攻击。
* **跨站请求伪造（CSRF）：** 使用防伪令牌防止 CSRF 攻击。
* **身份验证和授权漏洞：** 实现安全的身份验证和授权机制。
* **不安全的直接对象引用（IDOR）：** 验证用户对对象的访问以防止 IDOR 攻击。
* **文件上传漏洞：** 验证文件类型和大小以防止恶意文件上传。
* **拒绝服务（DoS）攻击：** 实现速率限制和其他措施防止 DoS 攻击。
* **反序列化漏洞：** 避免反序列化不受信任的数据。
* **依赖漏洞：** 定期更新依赖项以修补安全漏洞。

### 4.2. 输入验证

* **验证所有用户输入：** 在客户端和服务器端验证所有用户输入。
* **使用正则表达式：** 使用正则表达式验证输入格式。
* **清理输入：** 清理输入以删除或转义潜在恶意字符。
* **使用白名单：** 使用白名单仅允许已知的良好输入值。
* **限制输入长度：** 限制输入字段的长度以防止缓冲区溢出。

### 4.3. 身份验证和授权

* **使用强密码：** 强制执行强密码策略并使用 bcrypt 等密码哈希算法。
* **实现多因素身份验证（MFA）：** 使用 MFA 为身份验证过程添加额外的安全层。
* **使用基于角色的访问控制（RBAC）：** 使用 RBAC 基于用户角色控制对资源的访问。
* **使用基于声明的身份验证：** 使用基于声明的身份验证表示用户身份和权限。
* **实现适当的会话管理：** 实现安全的会话管理实践，包括会话超时和安全 cookie。
* **OAuth 2.0 和 OpenID Connect：** 利用行业标准协议进行身份验证和授权。

### 4.4. 数据保护

* **加密敏感数据：** 对静态和传输中的敏感数据进行加密。
* **使用密钥管理：** 使用安全的密钥管理系统存储和管理加密密钥。
* **保护连接字符串：** 保护连接字符串和其他敏感配置数据。
* **实现审计：** 实现审计以跟踪用户操作并检测安全漏洞。

### 4.5. 安全的 API 通信

* **使用 HTTPS：** 使用 HTTPS 加密客户端和服务器之间的通信。
* **实现 API 身份验证：** 使用 API 密钥、JWT 或其他身份验证机制保护 API 端点。
* **速率限制：** 实现速率限制防止 API 滥用。
* **输入验证：** 验证所有 API 输入以防止注入攻击。
* **输出编码：** 编码 API 输出以防止 XSS 攻击。

## 5. 测试方法

测试是软件开发过程的关键部分，有助于确保 C# 应用程序的质量和可靠性。

### 5.1. 单元测试

* **测试单个代码单元：** 单元测试应专注于独立测试单个类、方法或函数。
* **使用模拟框架：** 使用 Moq 或 NSubstitute 等模拟框架隔离代码单元并模拟依赖项。
* **遵循 Arrange-Act-Assert 模式：** 安排测试数据，对被测代码执行操作，并断言预期结果。
* **编写清晰简洁的测试：** 编写易于阅读和理解的测试。
* **测试边缘情况和错误条件：** 测试边缘情况和错误条件以确保代码正确处理它们。
* **追求高代码覆盖率：** 追求高代码覆盖率以确保大部分代码得到测试。

### 5.2. 集成测试

* **测试组件之间的交互：** 集成测试应专注于测试应用程序不同组件或模块之间的交互。
* **使用真实依赖项或测试替身：** 使用真实依赖项或测试替身模拟组件将运行的环境。
* **测试数据访问逻辑：** 测试数据访问逻辑以确保它与数据库正确交互。
* **测试 API 端点：** 测试 API 端点以确保它们正确处理请求和响应。

### 5.3. 端到端测试

* **测试整个应用程序流程：** 端到端测试应专注于从头到尾测试整个应用程序流程。
* **使用自动化框架：** 使用 Selenium 或 Playwright 等自动化框架自动化端到端测试。
* **测试用户界面：** 测试用户界面以确保它们功能正常且用户友好。
* **测试性能和可扩展性：** 测试性能和可扩展性以确保应用程序能够处理预期负载。

### 5.4. 测试组织

* **创建单独的测试项目：** 为单元测试、集成测试和端到端测试创建单独的测试项目。
* **按功能或模块组织测试：** 按功能或模块组织测试以提高可维护性。
* **使用描述性测试名称：** 使用清楚表明测试正在验证什么的描述性测试名称。
* **使用测试类别：** 使用测试类别将相关测试分组在一起。

### 5.5. 模拟和存根

* **使用模拟框架：** 使用 Moq 或 NSubstitute 等模拟框架创建模拟对象和存根依赖项。
* **为依赖项创建模拟对象：** 为难以或耗时设置的依赖项创建模拟对象。
* **存根方法调用：** 存根方法调用以返回特定值或抛出异常。
* **验证方法调用：** 验证方法是否使用预期参数调用。

## 6. 常见陷阱和注意事项

了解常见陷阱和注意事项可以帮助开发人员避免错误并编写更健壮的 C# 代码。

### 6.1. 常见错误

* **NullReferenceException：** 未正确处理空值。
* **异步编程的错误使用：** 使用同步操作阻塞主线程。
* **内存泄漏：** 未正确释放资源。
* **并发问题：** 竞态条件、死锁和其他并发问题。
* **未处理的异常：** 未正确捕获或记录异常。
* **SQL 注入：** 未参数化数据库查询。
* **XSS 攻击：** 未正确编码用户输入。
* **CSRF 攻击：** 未使用防伪令牌。
* **忽略代码分析警告：** 忽略编译器或代码分析工具的警告。

### 6.2. 边缘情况

* **空集合：** 正确处理空集合。
* **零值：** 正确处理零值。
* **最大值和最小值：** 正确处理最大值和最小值。
* **日期和时区：** 正确处理日期和时区。
* **Unicode 字符：** 正确处理 Unicode 字符。

### 6.3. 版本特定问题

* **C# 语言特性：** 了解新语言特性以及它们如何影响现有代码。
* **.NET Framework vs. .NET Core vs. .NET：** 了解不同 .NET 平台之间的差异。
* **破坏性变更：** 了解 .NET 框架新版本中的破坏性变更。

### 6.4. 兼容性问题

* **跨平台兼容性：** 确保代码在不同操作系统上正确工作。
* **向后兼容性：** 确保代码与 .NET 框架的旧版本兼容。
* **与其他语言的互操作性：** 确保代码可以与 C++ 或 Java 等其他语言互操作。

### 6.5. 调试策略

* **使用 Visual Studio 调试器：** 使用 Visual Studio 调试器逐步执行代码、检查变量并设置断点。
* **使用日志记录：** 使用日志记录跟踪代码的执行流程并记录重要信息。
* **使用单元测试：** 使用单元测试隔离和调试单个代码单元。
* **使用代码分析工具：** 使用代码分析工具识别代码中的潜在问题。
* **使用分析工具：** 使用分析工具识别性能瓶颈。

## 7. 工具和环境

选择正确的工具并正确配置开发环境可以显著提高生产力和代码质量。

### 7.1. 推荐的开发工具

* **Visual Studio：** C# 开发的主要 IDE。
* **Visual Studio Code：** 支持 C# 的轻量级代码编辑器。
* **JetBrains Rider：** 跨平台 .NET IDE。
* **NuGet 包管理器：** 用于管理依赖项。
* **Git：** 用于版本控制。
* **Resharper：** 强大的 Visual Studio 扩展，用于代码分析、重构和导航。

### 7.2. 构建配置

* **使用 MSBuild 或 dotnet CLI：** 使用 MSBuild 或 dotnet CLI 构建项目。
* **配置构建配置：** 为调试和发布构建配置不同的构建配置。
* **使用 NuGet 包还原：** 使用 NuGet 包还原在构建过程中自动下载依赖项。
* **签名程序集：** 签名程序集以防止篡改。
* **生成文档：** 从 XML 注释生成文档。
* **启用确定性构建：** 通过在项目文件中启用确定性构建确保构建可重现。

### 7.3. 代码检查和格式化

* **使用 StyleCop 分析器：** 使用 StyleCop 分析器强制执行编码风格规则。
* **使用 Roslyn 分析器：** 使用 Roslyn 分析器检测代码中的潜在问题。
* **配置 EditorConfig：** 使用 EditorConfig 为项目定义编码风格规则。
* **使用代码格式化程序：** 使用 Visual Studio 代码格式化程序等代码格式化程序自动格式化代码。

### 7.4. 部署最佳实践

* **选择部署目标：** 根据应用程序的要求选择部署目标（例如，Azure App Service、AWS Elastic Beanstalk、Docker）。
* **使用部署管道：** 使用部署管道自动化部署过程。
* **正确配置应用程序设置：** 为部署环境正确配置应用程序设置。
* **监控应用程序健康状况：** 监控应用程序健康状况以检测和解决问题。

### 7.5. CI/CD 集成

* **使用 CI/CD 平台：** 使用 Azure DevOps、GitHub Actions 或 Jenkins 等 CI/CD 平台自动化构建、测试和部署过程。
* **配置构建触发器：** 配置构建触发器在提交代码时自动启动构建。
* **运行单元测试和集成测试：** 作为构建过程的一部分运行单元测试和集成测试。
* **部署到不同环境：** 作为部署管道的一部分将应用程序部署到不同环境（例如，开发、暂存、生产）。
* **自动化代码审查：** 与代码审查工具集成以自动化代码审查的各个方面。

通过遵循这些最佳实践和编码标准，开发人员可以编写可维护、高性能、安全和可靠的 C# 代码。
