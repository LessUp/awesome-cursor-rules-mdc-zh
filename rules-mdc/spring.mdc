---
description: 此规则集为使用 Spring Boot 框架开发强大且可维护的 Java 后端应用程序提供全面的最佳实践和编码标准。专注于代码结构、性能、安全和测试。
globs: "*.java"
---
- **代码组织和结构**
  - **目录结构最佳实践**
    - **分层架构：** 将代码组织为层：`controller`、`service`、`repository`、`model`、`configuration` 和 `exception`。这提供了清晰的关注点分离。示例：
      
      src/
      └── main/
          └── java/
              └── com/example/app/
                  ├── controller/
                  │   └── OrderController.java
                  ├── service/
                  │   └── OrderService.java
                  ├── repository/
                  │   └── OrderRepository.java
                  ├── model/
                  │   └── Order.java
                  ├── configuration/
                  │   └── AppConfig.java
                  └── exception/
                      └── OrderNotFoundException.java
      
    - **基于功能的组织：** 按功能而不是层对代码进行分组。这将相关文件保持在一起以便于导航。当功能比技术分离更重要时使用。
      
      src/
      └── main/
          └── java/
              └── com/example/app/
                  ├── order/
                  │   ├── OrderController.java
                  │   ├── OrderService.java
                  │   ├── OrderRepository.java
                  │   └── Order.java
                  └── customer/
                      ├── CustomerController.java
                      ├── CustomerService.java
                      ├── CustomerRepository.java
                      └── Customer.java
      
  - **文件命名约定**
    - **类：** 使用 `PascalCase`。名称应该是表示类目的的名词。示例：`OrderService`、`ProductController`。
    - **接口：** 使用 `PascalCase`。通常以 `-able` 后缀命名（例如，`Runnable`、`Serializable`）或以 `I` 前缀（例如，`IUserService`）。示例：`OrderRepository`、`UserService`。
    - **方法：** 使用 `camelCase`。名称应该是表示执行动作的动词。示例：`createOrder()`、`calculateTotalPrice()`。
    - **变量：** 使用 `camelCase`。提供上下文的描述性和简洁名称。避免缩写，除非广泛理解。示例：`orderTotal`、`userList`。
    - **常量：** 使用 `UPPER_SNAKE_CASE`。示例：`MAX_RETRIES`、`DEFAULT_TIMEOUT`。
  - **模块组织**
    - **模块化单体：** 将应用程序分解为逻辑模块，每个模块都有特定的职责。这促进了可维护性和可测试性，而没有微服务的复杂性。Maven 或 Gradle 可用于管理模块。
    - **微服务：** 在适当时，考虑将应用程序分解为通过 API 通信的独立微服务。这提供了可扩展性和独立部署。示例：`Order Service`、`Payment Service`、`Customer Service`。
  - **组件架构**
    - **控制器：** 处理 HTTP 请求并将业务逻辑委托给服务。保持控制器精简并专注于请求映射和响应格式化。
    - **服务：** 包含应用程序的核心业务逻辑。服务应该是无状态的并且独立于 HTTP 关注点。
    - **仓储：** 处理数据访问和持久化。使用 Spring Data JPA 仓储简化数据库交互。
    - **数据传输对象（DTO）：** 使用 DTO 作为请求和响应负载，将 API 契约与领域模型分离。这允许在不影响内部数据结构的情况下灵活地发展 API。
  - **代码分割策略**
    - **按功能：** 根据功能将代码分割为模块，提高可维护性和可扩展性。
    - **按层：** 将代码分割为不同的层（表示层、业务层、数据层）以分离关注点并提高可测试性。

- **常见模式和反模式**
  - **设计模式**
    - **依赖注入：** Spring 的核心。对必需的依赖项使用构造函数注入，对可选的依赖项使用设置器注入。避免字段注入。
    - **控制反转（IoC）：** 让 Spring 容器管理 bean 的创建和生命周期。
    - **面向切面编程（AOP）：** 对日志记录、安全和事务管理等横切关注点使用 AOP。使用 `@Aspect` 注解。
    - **模板方法：** 当需要算法的不同实现时应用。Spring 的 `JdbcTemplate` 是一个经典示例。
    - **工厂模式：** 可用于抽象对象创建。
    - **单例模式：** Spring bean 默认是单例，但在处理有状态 bean 时要注意。
  - **推荐方法**
    - **配置属性：** 使用 `@ConfigurationProperties` 外部化配置以类型安全地访问属性。
    - **事件处理：** 使用 Spring 的事件发布和监听机制解耦组件。使用 `@EventListener` 注解。
    - **事务管理：** 使用 `@Transactional` 注解进行声明式事务管理。
    - **验证：** 使用 `@Validated` 和 JSR-303 注解进行请求参数和主体验证。
  - **反模式和代码异味**
    - **上帝类：** 避免职责过多的类。应用单一职责原则。
    - **长方法：** 将长方法分解为更小、更专注的方法。
    - **基本类型偏执：** 避免过度使用基本类型。将相关数据封装到值对象中。
    - **魔法数字/字符串：** 用常量或配置属性替换硬编码值。
    - **紧耦合：** 通过依赖注入和接口最小化组件之间的依赖关系。
  - **状态管理**
    - **无状态服务：** 服务应该是无状态的以提高可扩展性和并发性。
    - **会话管理：** 使用 Spring Session 在分布式环境中管理用户会话。考虑使用 Redis 或其他外部存储进行会话数据。
    - **缓存：** 战略性地实施缓存以减少数据库负载并提高响应时间。使用 Spring Cache 抽象与适当的缓存提供者。
  - **错误处理模式**
    - **全局异常处理：** 使用 `@ControllerAdvice` 和 `@ExceptionHandler` 全局处理异常并提供一致的错误响应。
    - **自定义异常：** 创建自定义异常类来表示应用程序特定的错误。
    - **日志记录：** 使用适当的级别（例如，`error`、`warn`、`info`）记录异常。
    - **返回有意义的错误响应：** 返回结构良好的错误响应，包含清晰的错误代码和消息。对错误响应使用一致的格式。

- **性能考虑**
  - **优化技术**
    - **数据库连接池：** 使用连接池（例如，HikariCP）重用数据库连接并减少开销。
    - **缓存：** 使用 Spring Cache 抽象实施缓存以存储频繁访问的数据。
    - **异步处理：** 对不需要同步执行的长时间运行任务使用 `@Async`。
    - **延迟加载：** 在 JPA 中对实体和关系使用延迟加载以避免加载不必要的数据。
    - **性能分析：** 使用性能分析工具（例如，VisualVM、JProfiler）识别性能瓶颈。
  - **内存管理**
    - **垃圾收集调优：** 调优 JVM 垃圾收集设置以获得最佳性能。监控 GC 性能并根据需要调整参数。
    - **对象池：** 考虑对频繁创建和销毁的对象使用对象池。
    - **避免内存泄漏：** 小心正确释放资源以防止内存泄漏。使用 try-with-resources 关闭流和其他资源。
  - **渲染优化**
    - *（不直接适用于 Spring 后端 - 专注于 API 响应时间和效率）*
    - **最小化数据传输：** 仅返回客户端需要的数据。
    - **使用高效的数据结构：** 对 API 响应使用适当的数据结构（例如，列表、映射）。
    - **压缩：** 为 API 响应启用 GZIP 压缩以减少通过网络传输的数据大小。
  - **包大小优化**
    - *（不直接适用于 Spring 后端 - 尽管依赖管理至关重要）*
    - **最小化依赖项：** 仅包含必要的依赖项。
    - **使用代码分析工具：** 使用 SonarQube 等工具识别未使用的代码和依赖项。
  - **延迟加载**
    - **JPA 延迟加载：** 对 JPA 关系使用延迟加载以避免加载不必要的数据。使用 `@OneToMany(fetch = FetchType.LAZY)` 注解。

- **安全最佳实践**
  - **常见漏洞和预防**
    - **SQL 注入：** 使用参数化查询或 ORM 框架（例如，Spring Data JPA）防止 SQL 注入。
    - **跨站脚本（XSS）：** 清理用户输入以防止 XSS 攻击。
    - **跨站请求伪造（CSRF）：** 使用 CSRF 保护机制（例如，Spring Security 的 CSRF 支持）。
    - **身份验证/授权缺陷：** 使用 Spring Security 实施强大的身份验证和授权机制。
    - **依赖项漏洞：** 定期扫描依赖项的已知漏洞并更新它们。
  - **输入验证**
    - **服务器端验证：** 始终在服务器端执行输入验证。
    - **JSR-303 验证：** 使用 JSR-303 注解验证请求参数和主体。
    - **自定义验证：** 为复杂验证规则实施自定义验证逻辑。
  - **身份验证和授权**
    - **Spring Security：** 使用 Spring Security 进行身份验证和授权。
    - **OAuth 2.0/OpenID Connect：** 使用 OAuth 2.0/OpenID Connect 将身份验证和授权委托给外部提供者。
    - **基于角色的访问控制（RBAC）：** 实施 RBAC 根据用户角色控制对资源的访问。
  - **数据保护**
    - **加密：** 对静态和传输中的敏感数据进行加密。
    - **哈希：** 使用强哈希算法（例如，bcrypt、Argon2）对密码进行哈希。
    - **数据掩码：** 在显示或记录敏感数据时对其进行掩码。
  - **安全 API 通信**
    - **HTTPS：** 对所有 API 通信使用 HTTPS。
    - **API 密钥：** 使用 API 密钥验证客户端。
    - **速率限制：** 实施速率限制以防止滥用。

- **测试方法**
  - **单元测试**
    - **JUnit：** 使用 JUnit 编写单元测试。
    - **Mockito：** 使用 Mockito 模拟依赖项。
    - **测试驱动开发（TDD）：** 在编写代码之前编写测试。
    - **专注于业务逻辑：** 将单元测试专注于应用程序的业务逻辑。
  - **集成测试**
    - **Spring Boot Test：** 使用 `@SpringBootTest` 注解进行集成测试。
    - **TestRestTemplate：** 使用 `TestRestTemplate` 测试 REST 端点。
    - **数据库测试：** 为集成测试使用内存数据库（例如，H2、嵌入式数据库）或测试数据库。
    - **验证组件交互：** 验证应用程序的不同组件是否正确协作。
  - **端到端测试**
    - **Selenium：** 使用 Selenium 进行 Web 应用程序的端到端测试。
    - **Cypress：** 使用 Cypress 作为端到端测试的另一种选择。
    - **测试整个系统：** 从用户界面到数据库测试整个系统。
  - **测试组织**
    - **单独的测试目录：** 将测试与源代码保持在单独的目录中。
    - **测试命名约定：** 对测试使用清晰一致的命名约定（例如，`ClassNameTest`）。
    - **按组件组织测试：** 按组件或功能组织测试。
  - **模拟和存根**
    - **Mockito 注解：** 使用 Mockito 注解（例如，`@Mock`、`@InjectMocks`）简化模拟。
    - **When/Then：** 使用 `when()` 和 `thenReturn()` 方法定义模拟行为。
    - **验证交互：** 使用 `verify()` 方法验证模拟交互是否发生。

- **常见陷阱和注意事项**
  - **常见错误**
    - **过度工程：** 避免过度工程解决方案。保持简单，仅在需要时添加复杂性。
    - **忽略异常：** 不要捕获异常并忽略它们。始终记录异常并适当处理它们。
    - **硬编码值：** 避免硬编码值。使用配置属性代替。
    - **不正确使用依赖注入：** 使用依赖注入解耦组件并提高可测试性。
  - **边缘情况**
    - **空值：** 优雅地处理空值。
    - **并发问题：** 在处理共享资源时注意并发问题。
    - **资源耗尽：** 优雅地处理资源耗尽（例如，数据库连接、内存）。
  - **版本特定问题**
    - **检查发布说明：** 查看 Spring Boot 及其依赖项每个版本的发布说明以识别潜在问题。
    - **测试升级：** 彻底测试升级以确保兼容性。
  - **兼容性问题**
    - **依赖项冲突：** 使用 Maven 或 Gradle 管理依赖项冲突。
    - **Java 版本兼容性：** 确保 Spring Boot 与 Java 版本之间的兼容性。
  - **调试策略**
    - **日志记录：** 大量使用日志记录跟踪执行流程并识别问题。
    - **调试器：** 使用调试器逐步执行代码并检查变量。
    - **远程调试：** 使用远程调试来调试在远程环境中运行的应用程序。

- **工具和环境**
  - **推荐的开发工具**
    - **IntelliJ IDEA：** 具有出色 Spring Boot 支持的流行 IDE。
    - **Eclipse：** 另一个具有 Spring Tool Suite 插件的流行 IDE。
    - **Spring Initializr：** 用于生成 Spring Boot 项目的基于 Web 的工具。
  - **构建配置**
    - **Maven：** 使用 Maven 进行依赖管理和构建项目。
    - **Gradle：** 使用 Gradle 作为 Maven 的另一种选择。
    - **Spring Boot 插件：** 使用 Spring Boot Maven 或 Gradle 插件构建可执行 JAR。
  - **代码检查和格式化**
    - **Checkstyle：** 使用 Checkstyle 强制执行编码标准。
    - **PMD：** 使用 PMD 查找潜在错误和代码异味。
    - **SpotBugs：** 使用 SpotBugs 查找代码中的潜在错误模式。
    - **Prettier：** 使用 Prettier 一致地格式化代码。
  - **部署最佳实践**
    - **容器化：** 使用 Docker 容器化应用程序。
    - **云平台：** 将应用程序部署到云平台（例如，AWS、Azure、GCP）。
    - **不可变基础设施：** 使用不可变基础设施部署应用程序。
  - **CI/CD 集成**
    - **Jenkins：** 使用 Jenkins 进行持续集成和持续部署。
    - **GitLab CI：** 使用 GitLab CI 作为另一种 CI/CD 选择。
    - **GitHub Actions：** 使用 GitHub Actions 自动化构建、测试和部署工作流程。

- **附加提示**
    - **使用 Spring Boot DevTools：** 这些工具在开发期间提供自动应用程序重启、实时重新加载和其他有用功能。
    - **监控应用程序健康：** 使用 Spring Boot Actuator 监控应用程序健康和性能指标。
    - **保持最新：** 跟上最新的 Spring Boot 发布和最佳实践。
