---
description: 此规则为 React Native 开发提供全面的最佳实践和编码标准，涵盖代码组织、性能、安全、测试和常见陷阱。
globs: "*.js,*.jsx,*.ts,*.tsx"
---
- 使用 TypeScript 确保类型安全并提高代码可维护性。
- 优先使用带钩子的函数组件而不是类组件，以获得简洁性和可重用性。
- 保持清晰一致的项目结构以确保可扩展性和可维护性。

## 1. 代码组织和结构：

- **目录结构：**
    - 采用基于功能或基于组件的结构。例如：
        ```
        src/
        ├── components/
        │   ├── Button/
        │   │   ├── Button.tsx
        │   │   ├── Button.styles.ts
        │   │   ├── Button.test.tsx
        │   ├── Input/
        │   └── ...
        ├── screens/
        │   ├── Home/
        │   │   ├── HomeScreen.tsx
        │   │   ├── HomeScreen.styles.ts
        │   │   ├── HomeScreen.test.tsx
        │   ├── Profile/
        │   └── ...
        ├── navigation/
        ├── services/
        ├── utils/
        ├── types/
        └── App.tsx
        ```
    - 将关注点分离到不同的目录中（例如，components、screens、navigation、services、utils、types）。

- **文件命名约定：**
    - 为文件和组件使用描述性名称（例如，`HomeScreen.tsx`、`useUserData.ts`）。
    - 遵循一致的命名约定（例如，组件使用 PascalCase，函数和变量使用 camelCase）。
    - 样式文件使用 `.styles.ts`，测试文件使用 `.test.tsx`，以保持组件可读性和组织性。

- **模块组织：**
    - 将相关组件和模块分组为逻辑单元。
    - 使用绝对导入和模块别名避免长的相对路径（例如，`@components/Button` 而不是 `../../../components/Button`）。
    - 在 `tsconfig.json` 或 `jsconfig.json` 中配置模块别名。

- **组件架构：**
    - 优先使用具有单一职责的小型可重用组件（单一职责原则）。
    - 使用组合而不是继承来创建复杂组件。
    - 考虑使用 React Native Paper 或 NativeBase 等 UI 库获取预构建组件。

- **代码分割策略：**
    - 为不立即需要的屏幕或组件实施延迟加载。
    - 使用 `React.lazy` 和 `Suspense` 按需加载组件。
    - 利用动态导入进行模块的条件加载。

## 2. 常见模式和反模式：

- **设计模式：**
    - **高阶组件（HOCs）：** 使用 HOCs 处理横切关注点，如身份验证或日志记录。
    - **渲染属性：** 使用渲染属性在 React 组件之间共享代码。
    - **钩子：** 使用自定义钩子封装逻辑和有状态行为。

- **推荐方法：**
    - **状态管理：**
        - 使用 React Context 进行简单状态管理。
        - 使用 Redux、Zustand 或 Jotai 进行复杂状态管理。
        - 考虑使用 Recoil 进行细粒度状态管理。
    - **API 调用：**
        - 使用 `axios` 或 `fetch` 进行 API 请求。
        - 创建服务层处理 API 调用和数据转换。
    - **导航：**
        - 使用 React Navigation 管理应用导航。
        - 在单独的模块中定义导航堆栈和路由。

- **反模式和代码异味：**
    - **长组件文件：** 将大型组件分解为更小、更易管理的部分。
    - **深度嵌套组件：** 避免过度嵌套，这可能影响性能。
    - **直接修改状态：** 始终使用 `setState` 或状态管理库更新状态。
    - **不必要的重新渲染：** 优化组件以防止不必要的重新渲染。
    - **全局样式：** 避免使用全局样式，因为它们可能导致冲突并使应用程序难以维护。

- **状态管理最佳实践：**
    - 选择适合应用程序复杂性的状态管理解决方案。
    - 保持状态最小化，尽可能派生值。
    - 使用选择器访问状态并记忆化计算值。

- **错误处理模式：**
    - 使用 `try...catch` 块优雅地处理错误。
    - 实施全局错误处理器捕获未处理的异常。
    - 将错误记录到远程监控服务。

## 3. 性能考虑：

- **优化技术：**
    - **记忆化：** 使用 `React.memo` 记忆化组件并防止不必要的重新渲染。
    - **纯组件：** 为仅依赖 props 的组件扩展 `React.PureComponent`。
    - **防抖和节流：** 使用防抖和节流限制函数调用频率。
    - **虚拟化：** 使用 `FlatList` 或 `SectionList` 渲染大型数据列表。

- **内存管理：**
    - 通过正确清理事件监听器和计时器避免内存泄漏。
    - 使用 `useCallback` 和 `useMemo` 防止在每次渲染时创建新函数和对象。

- **渲染优化：**
    - 通过优化组件更新最小化重新渲染次数。
    - 使用 `shouldComponentUpdate`（对于类组件）或 `React.memo` 控制重新渲染。
    - 避免使用内联样式，因为它们在每次渲染时都会重新创建。

- **包大小优化：**
    - 使用代码分割减少初始包大小。
    - 删除未使用的代码和依赖项。
    - 使用启用树摇的 Metro 或 Webpack 等打包器。
    - 压缩图像和其他资源。

- **延迟加载策略：**
    - 使用 `React.lazy` 和 `Suspense` 为图像和其他资源实施延迟加载。
    - 使用动态导入按需加载模块。

## 4. 安全最佳实践：

- **常见漏洞：**
    - **跨站脚本（XSS）：** 清理用户输入以防止 XSS 攻击。
    - **SQL 注入：** 使用参数化查询防止 SQL 注入攻击。
    - **跨站请求伪造（CSRF）：** 实施 CSRF 保护令牌。
    - **中间人（MITM）攻击：** 使用 HTTPS 加密通信。

- **输入验证：**
    - 在客户端和服务器端验证用户输入。
    - 使用正则表达式或验证库强制执行输入约束。

- **身份验证和授权模式：**
    - 使用 OAuth 2.0 或 JWT 等安全身份验证协议。
    - 实施基于角色的访问控制（RBAC）限制对敏感资源的访问。

- **数据保护策略：**
    - 对静态和传输中的敏感数据进行加密。
    - 使用安全存储机制存储 API 密钥和其他机密。

- **安全 API 通信：**
    - 对所有 API 通信使用 HTTPS。
    - 实施 API 速率限制防止滥用。
    - 验证 API 响应以防止数据注入攻击。

## 5. 测试方法：

- **单元测试策略：**
    - 为单个组件和模块编写单元测试。
    - 使用 Jest 或 Mocha 等测试框架。
    - 模拟依赖项以隔离被测试的组件。

- **集成测试：**
    - 编写集成测试验证组件和模块之间的交互。
    - 测试与外部 API 和服务的集成。

- **端到端测试：**
    - 编写端到端测试验证整个应用程序流程。
    - 使用 Detox 或 Appium 等测试框架。

- **测试组织：**
    - 根据组件或模块将测试组织到单独的目录中。
    - 为测试文件和测试用例使用描述性名称。

- **模拟和存根：**
    - 使用模拟和存根隔离组件并在测试期间控制其行为。
    - 使用 Jest 或 Sinon 等模拟库。

## 6. 常见陷阱和注意事项：

- **常见错误：**
    - **直接修改状态：** 始终使用 `setState` 或状态管理库更新状态。
    - **忽略平台差异：** 在 iOS 和 Android 设备上测试应用程序。
    - **过度优化：** 仅在必要时优化，因为过早优化可能导致复杂代码。
    - **不使用调试器：** 利用 React Native 调试器进行高效调试。

- **边缘情况：**
    - **处理设备方向变化：** 实施逻辑优雅地处理设备方向变化。
    - **处理网络连接问题：** 为网络连接问题实施错误处理。
    - **处理不同屏幕尺寸和密度：** 设计 UI 以适应不同的屏幕尺寸和密度。

- **版本特定问题：**
    - 注意 React Native 及其依赖项的破坏性变更。
    - 使用不同版本的 React Native 测试应用程序。

- **兼容性问题：**
    - 确保应用程序与目标操作系统和设备兼容。
    - 使用 polyfills 支持较旧的浏览器和设备。

- **调试策略：**
    - 使用 React Native 调试器检查组件树和状态。
    - 使用控制台记录消息和调试代码。
    - 使用远程调试工具在物理设备上调试。

## 7. 工具和环境：

- **推荐的开发工具：**
    - **VS Code：** 使用带有 React Native Tools 扩展的 VS Code 进行调试和代码补全。
    - **React Native CLI：** 使用 React Native CLI 创建和管理 React Native 项目。
    - **Expo CLI：** 使用 Expo CLI 开发和测试无需原生代码的 React Native 应用程序。
    - **Android Studio：** 使用 Android Studio 构建和调试 Android 应用程序。
    - **Xcode：** 使用 Xcode 构建和调试 iOS 应用程序。

- **构建配置：**
    - 使用 Gradle（Android）或 CocoaPods（iOS）等构建系统管理依赖项。
    - 为不同环境（例如，开发、暂存、生产）配置构建变体。

- **代码检查和格式化：**
    - 使用 ESLint 和 Prettier 强制执行代码风格并捕获潜在错误。
    - 配置 ESLint 和 Prettier 在保存时自动格式化代码。

- **部署最佳实践：**
    - 使用持续集成和持续部署（CI/CD）管道自动化部署过程。
    - 使用 App Center 或 Bitrise 等服务构建和部署 React Native 应用程序。

- **CI/CD 集成：**
    - 将代码存储库与 GitHub Actions 或 CircleCI 等 CI/CD 服务集成。
    - 配置 CI/CD 管道在每次提交时运行测试并构建应用程序。
