---
description: 强制执行 TypeScript 开发的最佳实践，包括编码标准、性能考虑和常见陷阱。此规则为开发人员编写清洁、可维护和可扩展的 TypeScript 代码提供可操作的指导。
globs: "*.ts?(x)"
---
# TypeScript 最佳实践和编码标准

本文档概述了开发 TypeScript 应用程序的最佳实践和编码标准。遵循这些指南将有助于确保代码质量、可维护性和可扩展性。

## 1. 代码组织和结构

- **目录结构：**
    - **基于功能：** 将与特定功能相关的文件分组到专用目录中。

    src/
    ├── feature1/
    │   ├── components/
    │   │   ├── ComponentA.tsx
    │   │   └── ComponentB.tsx
    │   ├── services/
    │   │   └── feature1.service.ts
    │   ├── types.ts
    │   └── feature1.module.ts
    ├── feature2/
    │   └── ...
    └── shared/
        ├── components/
        │   └── ReusableComponent.tsx
        ├── services/
        │   └── api.service.ts
        └── types/
            └── global.d.ts

    - **基于类型：** 根据文件的角色（组件、服务、类型等）分离文件。

    src/
    ├── components/
    │   ├── Feature1Component.tsx
    │   └── Feature2Component.tsx
    ├── services/
    │   ├── feature1.service.ts
    │   └── feature2.service.ts
    ├── types/
    │   ├── feature1.types.ts
    │   └── feature2.types.ts
    └── modules/
        ├── feature1.module.ts
        └── feature2.module.ts

    - 选择最适合项目复杂性和团队偏好的结构。一致性是关键。

- **文件命名约定：**
    - 使用描述性和一致的文件名。
    - 组件：`ComponentName.tsx`
    - 服务：`serviceName.service.ts`
    - 类型：`typeName.types.ts` 或 `types.ts`（如果分组相关类型）
    - 模块：`moduleName.module.ts`
    - 接口：`IInterfaceName.ts`（或 `interfaceName.interface.ts`，如果首选并在整个代码库中保持一致）

- **模块组织：**
    - 使用 ES 模块（`import`/`export`）实现模块化和可重用性。
    - 优先使用命名导出而不是默认导出，以获得更好的可发现性和重构能力。
    - 将相关功能分组到模块中。
    - 避免循环依赖。

- **组件架构：**
    - 考虑使用基于组件的架构，如 React、Angular 或 Vue.js。
    - 遵循组件设计原则：单一职责原则、关注点分离。
    - 使用组合优于继承。
    - 保持组件小而专注。

- **代码分割策略：**
    - 将应用程序分割为更小的块以改善初始加载时间。
    - 对不立即需要的模块和组件实施延迟加载。
    - 使用动态导入（`import()`）。
    - Webpack、Parcel 和其他打包器提供对代码分割的内置支持。

## 2. 常见模式和反模式

- **设计模式：**
    - **工厂模式：** 使用工厂创建具有复杂初始化逻辑的对象。
    - **单例模式：** 谨慎使用，仅在真正需要单个实例时使用。
    - **观察者模式：** 实现响应式模式来处理事件和数据变化。
    - **策略模式：** 定义一系列算法并将每个算法封装到单独的类中。
    - **依赖注入：** 通过将依赖项注入组件和服务来减少耦合。

- **推荐方法：**
    - **数据获取：** 使用 `axios` 或 `fetch` 等库进行 API 请求。
    - **状态管理：** 选择适合应用程序复杂性的状态管理解决方案（例如，React Context、Redux、Zustand、MobX）。
    - **表单处理：** 使用 `react-hook-form` 或 `formik` 等库管理表单状态和验证。

- **反模式和代码异味：**
    - **过度使用 `any` 类型：** 尽可能避免使用 `any`。使用更具体的类型或泛型。
    - **长方法/函数：** 将大型函数分解为更小、更易管理的单元。
    - **深度嵌套代码：** 重构深度嵌套的代码以提高可读性。
    - **魔法数字/字符串：** 对具有特定含义的值使用常量。
    - **重复代码：** 将通用逻辑提取到可重用的函数或组件中。
    - **忽略错误：** 始终优雅地处理错误。不要只是捕获并忽略它们。
    - **过度注释：** 编写自文档化代码，仅在必要时使用注释来解释复杂逻辑。

- **状态管理最佳实践：**
    - 根据项目需求选择状态管理库：React Context API、Redux、Zustand、MobX。
    - 保持状态最小化，尽可能派生值。
    - 遵循不可变更新模式（特别是使用 Redux）。
    - 使用选择器访问状态。
    - 集中状态逻辑。

- **错误处理模式：**
    - 使用 `try...catch` 块处理潜在错误。
    - 实施全局错误处理程序来捕获未处理的异常。
    - 使用错误日志记录来跟踪生产中的错误。
    - 使用判别联合来表示不同的错误状态。
    - 为瞬态错误实施重试机制。

## 3. 性能考虑

- **优化技术：**
    - **记忆化：** 使用记忆化技术（例如，`React.memo`、`useMemo`）避免不必要的重新渲染。
    - **防抖和节流：** 限制函数响应用户输入的执行速率。
    - **虚拟化：** 对渲染大型列表或表格使用虚拟化。
    - **代码分割：** 将代码分割为更小的块以减少初始加载时间。

- **内存管理：**
    - 通过适当清理资源（例如，事件监听器、计时器）避免内存泄漏。
    - 使用弱引用避免可能阻止垃圾收集的循环依赖。
    - 分析应用程序以识别内存泄漏。

- **渲染优化：**
    - 最小化 DOM 操作。
    - 使用 CSS 变换和动画而不是 JavaScript 动画。
    - 优化图像和其他资源。
    - 使用 `shouldComponentUpdate` 生命周期方法或 `React.memo` 防止不必要的重新渲染。

- **包大小优化：**
    - 使用树摇来从包中删除未使用的代码。
    - 压缩代码以减少包大小。
    - 使用 gzip 或 Brotli 压缩代码。
    - 使用代码分割仅加载特定页面或组件所需的代码。

- **延迟加载策略：**
    - 延迟加载不立即需要的模块和组件。
    - 使用动态导入（`import()`）按需加载模块。
    - 实施加载指示器，在模块加载时向用户提供反馈。

## 4. 安全最佳实践

- **常见漏洞和预防：**
    - **跨站脚本（XSS）：** 清理用户输入并转义输出以防止 XSS 攻击。
    - **跨站请求伪造（CSRF）：** 使用反 CSRF 令牌防止 CSRF 攻击。
    - **SQL 注入：** 使用参数化查询或 ORM 防止 SQL 注入攻击（与后端 TypeScript 相关）。
    - **拒绝服务（DoS）：** 实施速率限制和其他措施防止 DoS 攻击。
    - **中间人（MitM）：** 使用 HTTPS 加密客户端和服务器之间的通信。

- **输入验证：**
    - 在客户端和服务器端验证所有用户输入。
    - 使用强验证规则防止恶意输入。
    - 清理用户输入以删除潜在有害字符。

- **身份验证和授权模式：**
    - 使用安全的身份验证机制验证用户身份。
    - 实施授权检查控制对资源的访问。
    - 使用基于角色的访问控制（RBAC）管理用户权限。
    - 使用 JSON Web 令牌（JWT）进行无状态身份验证。

- **数据保护策略：**
    - 对静态和传输中的敏感数据进行加密。
    - 使用强加密算法。
    - 使用哈希算法和盐安全存储密码。
    - 保护 API 密钥和其他机密。

- **安全 API 通信：**
    - 对所有 API 通信使用 HTTPS。
    - 为 API 端点实施适当的身份验证和授权。
    - 使用速率限制防止滥用。
    - 验证 API 请求和响应。

## 5. 测试方法

- **单元测试策略：**
    - 为单个函数和组件编写单元测试。
    - 使用模拟和存根来隔离代码单元。
    - 测试边缘情况和错误条件。
    - 争取高代码覆盖率。

- **集成测试：**
    - 测试不同模块和组件之间的交互。
    - 验证应用程序的不同部分是否正确协作。

- **端到端测试：**
    - 从用户角度测试整个应用程序。
    - 使用 Cypress 或 Playwright 等工具自动化端到端测试。

- **测试组织：**
    - 以便于查找和运行的方式组织测试。
    - 按功能或模块分组测试。
    - 使用描述性测试名称。

- **模拟和存根：**
    - 使用模拟和存根来隔离代码单元并模拟依赖项。
    - 使用 Jest 或 Sinon.js 等模拟库。

## 6. 常见陷阱和注意事项

- **常见错误：**
    - 不正确处理异步操作（Promises、async/await）。
    - 未正确处理错误。
    - 过度使用 `any` 类型。
    - 忽略编译器警告。
    - 不保持依赖项更新。

- **边缘情况：**
    - 处理不同的浏览器版本和设备。
    - 处理网络延迟和故障。
    - 处理不同的时区和区域设置。
    - 处理大型数据集和复杂计算。

- **版本特定问题：**
    - 注意 TypeScript 和相关库新版本中的破坏性变更。
    - 查阅每个新版本的发布说明以识别潜在问题。
    - 使用 TypeScript 的编译器选项来定位特定的 ECMAScript 版本，并在需要时保持向后兼容性。

- **兼容性问题：**
    - 确保代码与目标浏览器和设备兼容。
    - 使用 polyfills 为较旧的浏览器提供支持。
    - 在不同平台上测试代码以识别兼容性问题。

- **调试策略：**
    - 使用调试器逐步执行代码并检查变量。
    - 使用控制台日志记录跟踪执行流程并识别错误。
    - 使用 TypeScript 的类型检查及早捕获错误。
    - 使用源映射调试已转译或压缩的代码。
    - 学会阅读和理解堆栈跟踪。

## 7. 工具和环境

- **推荐的开发工具：**
    - **IDE：** 带有 TypeScript 扩展的 Visual Studio Code。
    - **包管理器：** npm 或 Yarn。
    - **打包器：** Webpack、Parcel 或 Rollup。
    - **代码检查器：** 带有 TypeScript 特定规则的 ESLint。
    - **格式化器：** Prettier。
    - **测试框架：** Jest、Mocha 或 Jasmine。

- **构建配置：**
    - 使用 `tsconfig.json` 文件配置 TypeScript 编译器。
    - 配置编译器选项，如 `target`、`module`、`jsx` 和 `strict`。
    - 使用 TypeScript 的项目引用来组织大型项目。

- **代码检查和格式化：**
    - 使用带有 TypeScript 特定规则的 ESLint 强制执行编码标准。
    - 使用 Prettier 自动格式化代码。
    - 使用 Git 钩子或 CI/CD 管道将代码检查和格式化集成到开发工作流中。

- **部署最佳实践：**
    - 使用构建过程转译和打包代码。
    - 压缩和压缩代码以减少包大小。
    - 使用 CDN 提供静态资源。
    - 实施缓存策略以提高性能。

- **CI/CD 集成：**
    - 将测试和代码检查器集成到 CI/CD 管道中。
    - 自动化构建和部署过程。
    - 使用环境变量为不同环境配置应用程序。
