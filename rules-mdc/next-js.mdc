---
description: 此规则提供 Next.js 开发的综合指导，涵盖代码组织、性能、安全、测试和常见陷阱。它帮助开发人员通过遵循社区认可的最佳实践和编码标准来构建强大、可扩展和可维护的 Next.js 应用程序。
globs: "*.js,*.jsx,*.ts,*.tsx"
---
# Next.js 最佳实践

本文档概述了开发 Next.js 应用程序的最佳实践，重点关注代码组织、性能优化、安全、测试策略和要避免的常见陷阱。遵循这些指南将帮助您构建强大、可扩展和可维护的应用程序。

## 1. 代码组织和结构

### 目录结构

*   **`app/`**：（推荐 - Next.js 13+）包含路由处理程序、服务器组件和客户端组件。
    *   `page.tsx`：表示路由的 UI。
    *   `layout.tsx`：定义路由及其子路由的布局。
    *   `loading.tsx`：在路由段加载时显示加载 UI。
    *   `error.tsx`：处理路由段内的错误。
    *   `head.tsx`：管理路由的 `<head>` 元数据。
    *   `route.ts`：定义服务器端路由处理程序（API 路由）。
    *   `[dynamic-segment]`：动态路由段，使用方括号。
    *   `@folder-name`：路由组，用于组织路由而不影响 URL 结构。
*   **`pages/`**：（遗留 - Next.js 13 之前）包含页面组件。
    *   `api/`：无服务器函数（API 路由）。
    *   `_app.js/tsx`：自定义 App 组件（包装所有页面）。
    *   `_document.js/tsx`：自定义 Document 组件（控制整个 HTML 文档）。
*   **`components/`**：可重用的 UI 组件。
*   **`lib/`**：实用函数、辅助函数和第三方集成。
*   **`hooks/`**：自定义 React 钩子。
*   **`styles/`**：全局样式和 CSS 模块。
*   **`public/`**：静态资源（图像、字体等）。
*   **`types/`**：TypeScript 类型定义和接口。
*   **`utils/`**：包含实用程序和辅助函数，以及任何与 API 相关的逻辑。

**建议：** 对于新项目，优先使用 `app/` 目录结构，因为它与最新的 Next.js 功能和最佳实践保持一致。使用 `pages/` 时，保持简单并在可行时迁移到 `app/`。

### 文件命名约定

*   **组件：** `ComponentName.jsx` 或 `ComponentName.tsx`
*   **页面：** `page.js`、`page.jsx`、`page.ts`、`page.tsx`（在 `app` 或 `pages` 目录内）
*   **布局：** `layout.js`、`layout.jsx`、`layout.ts`、`layout.tsx`（在 `app` 目录内）
*   **API 路由：** `route.js`、`route.ts`（在 `app/api` 目录或 `pages/api` 目录内）
*   **钩子：** `useHookName.js` 或 `useHookName.ts`
*   **样式：** `ComponentName.module.css` 或 `ComponentName.module.scss`
*   **类型：** `types.ts` 或 `interfaces.ts`

### 模块组织

*   **共置：** 将相关的组件、样式和测试保存在同一目录中。
*   **基于功能的模块：** 按功能而不是类型分组文件（例如，`components/user-profile/`，而不是 `components/button`、`components/form`）。
*   **避免深度嵌套目录：** 保持目录结构相对扁平以改善导航。

### 组件架构

*   **展示型 vs. 容器型组件：** 将处理数据获取和状态管理的组件（容器组件）与仅渲染 UI 的组件（展示型组件）分离。
*   **原子设计：** 将组件组织为原子、分子、有机体、模板和页面，以获得更好的可重用性和可维护性。
*   **组合优于继承：** 优先使用组合来创建灵活和可重用的组件。
*   **服务器组件（app 目录）：** 默认使用服务器组件以提高性能。仅在需要交互性（事件处理程序、useState、useEffect）时使用客户端组件。

### 代码分割

*   **动态导入：** 使用 `next/dynamic` 仅在需要时加载组件，改善初始加载时间。示例：`dynamic(() => import('../components/MyComponent'))`。
*   **路由级代码分割：** Next.js 根据路由自动分割代码，因此每个页面只加载必要的 JavaScript。
*   **细粒度代码分割：** 将大型组件分解为可以独立加载的更小块。

## 2. 常见模式和反模式

### 设计模式

*   **高阶组件（HOCs）：** 可重用的组件逻辑。
*   **渲染属性：** 使用值为函数的属性在 React 组件之间共享代码。
*   **钩子：** 将有状态逻辑提取到可重用函数中。
*   **上下文 API：** 管理全局状态。
*   **复合组件：** 组合多个隐式协作的组件。

### 推荐方法

*   **数据获取：** 使用 `getServerSideProps` 或 `getStaticProps` 或服务器组件在服务器端获取数据。使用 `SWR` 或 `React Query` 进行客户端数据获取和缓存。
*   **样式：** 使用 CSS 模块、Styled Components 或 Tailwind CSS 进行组件级样式。优先使用 Tailwind CSS 进行快速开发。
*   **状态管理：** 使用 React Context、Zustand、Jotai 或 Recoil 管理全局状态。Redux 是一个选项，但对于较小的 Next.js 项目通常过于复杂。
*   **表单处理：** 使用 `react-hook-form` 管理表单和验证。
*   **API 路由：** 使用 Next.js API 路由进行无服务器函数。

### 反模式和代码异味

*   **过度获取数据：** 仅获取组件需要的数据。
*   **阻塞主线程：** 避免在主线程中进行长时间运行的同步操作。
*   **直接修改状态：** 始终使用 `setState` 或钩子更新状态。
*   **不记忆化组件：** 使用 `React.memo` 防止不必要的重新渲染。
*   **使用 `useEffect` 而不带依赖数组：** 确保依赖数组完整以防止意外行为。
*   **在客户端组件中编写服务器端代码：** 可能暴露机密或导致意外行为。

### 状态管理

*   **本地状态：** 对组件特定状态使用 `useState`。
*   **上下文 API：** 对不经常更改的应用程序范围状态使用 `useContext`。
*   **第三方库：** 对更复杂的状态管理需求使用 `Zustand`、`Jotai` 或 `Recoil`。对于许多 Next.js 用例，这些是 Redux 的更简单、更高性能的替代方案。

### 错误处理

*   **`try...catch`：** 使用 `try...catch` 块处理异步操作中的错误。
*   **错误边界组件：** 创建可重用的错误边界组件以捕获子组件中的错误。实现 `getDerivedStateFromError` 或 `componentDidCatch` 生命周期方法。
*   **集中式错误日志记录：** 将错误记录到 Sentry 或 Bugsnag 等中央服务。
*   **自定义错误页面：** 使用 `_error.js` 或 `_error.tsx` 创建自定义错误页面。
*   **路由级错误处理（app 目录）：** 在路由段内使用 `error.tsx` 处理特定于该路由的错误。

## 3. 性能考虑

### 优化技术

*   **图像优化：** 使用 `next/image` 组件进行自动图像优化，包括延迟加载和响应式图像。
*   **字体优化：** 使用 `next/font` 优化字体加载并防止布局偏移。
*   **代码分割：** 使用动态导入和路由级代码分割减少初始加载时间。
*   **缓存：** 使用缓存策略（例如，`Cache-Control` 标头、`SWR`、`React Query`）减少数据获取开销。
*   **记忆化：** 使用 `React.memo` 防止组件的不必要重新渲染。
*   **预取：** 使用 `<Link prefetch>` 标签预取可能被访问的页面。
*   **SSR/SSG：** 对不经常更改的内容使用静态站点生成（SSG），对动态内容使用服务器端渲染（SSR）。
*   **增量静态再生（ISR）：** 使用 ISR 定期更新静态生成的页面。

### 内存管理

*   **避免内存泄漏：** 在 `useEffect` 钩子中清理事件监听器和计时器。
*   **最小化重新渲染：** 仅在必要时更新状态以减少重新渲染次数。
*   **使用不可变数据结构：** 避免直接修改数据以防止意外副作用。

### 渲染优化

*   **服务器组件（app 目录）：** 尽可能在服务器上渲染以减少客户端 JavaScript。
*   **客户端组件（app 目录）：** 仅在需要交互性时使用客户端组件。使用 `React.lazy` 延迟渲染非关键客户端组件。

### 包大小优化

*   **分析包大小：** 使用 `webpack-bundle-analyzer` 等工具识别大型依赖项。
*   **删除未使用的代码：** 使用树摇来从包中删除未使用的代码。
*   **使用更小的依赖项：** 用更小、更轻量的替代方案替换大型依赖项。
*   **压缩：** 在服务器上启用 Gzip 或 Brotli 压缩以减少传输文件的大小。

### 延迟加载

*   **图像：** 使用 `next/image` 自动延迟加载图像。
*   **组件：** 使用 `next/dynamic` 延迟加载组件。
*   **交叉观察器：** 使用交叉观察器 API 手动延迟加载内容。

## 4. 安全最佳实践

### 常见漏洞

*   **跨站脚本（XSS）：** 清理用户输入以防止 XSS 攻击。在直接从用户输入渲染 HTML 时要特别小心。
*   **跨站请求伪造（CSRF）：** 使用 CSRF 令牌防止 CSRF 攻击。
*   **SQL 注入：** 使用参数化查询或 ORM 防止 SQL 注入攻击。
*   **身份验证和授权漏洞：** 实施安全的身份验证和授权机制。避免在客户端代码中存储机密。
*   **暴露敏感数据：** 通过将 API 密钥和其他敏感数据存储在环境变量中并在服务器端访问它们来保护它们。

### 输入验证

*   **服务器端验证：** 始终在服务器端验证用户输入。
*   **客户端验证：** 使用客户端验证提供即时反馈，但不要依赖它来确保安全。
*   **清理输入：** 清理用户输入以删除潜在的恶意代码。
*   **使用验证库：** 使用 `zod` 或 `yup` 等库验证用户输入。

### 身份验证和授权

*   **使用安全的身份验证提供者：** 使用 Auth0、NextAuth.js 或 Firebase Authentication 等服务进行安全身份验证。
*   **安全存储令牌：** 将令牌存储在仅 HTTP 的 cookie 或本地存储中。
*   **实施基于角色的访问控制：** 使用基于角色的访问控制限制对敏感资源的访问。
*   **保护 API 端点：** 使用身份验证中间件保护 API 端点。

### 数据保护

*   **加密敏感数据：** 对静态和传输中的敏感数据进行加密。
*   **使用 HTTPS：** 使用 HTTPS 加密客户端和服务器之间的通信。
*   **定期更新依赖项：** 保持依赖项最新以修补安全漏洞。
*   **安全环境变量：** 永远不要将环境变量提交到存储库。如有必要，使用机密管理工具。

### 安全 API 通信

*   **使用 HTTPS：** 对所有 API 通信使用 HTTPS。
*   **验证 API 请求：** 使用 API 密钥或令牌验证 API 请求。
*   **速率限制：** 实施速率限制以防止 API 滥用。
*   **输入验证：** 验证所有 API 请求参数。
*   **输出编码：** 正确编码 API 响应以防止注入攻击。

## 5. 测试方法

### 单元测试

*   **测试单个组件：** 为单个组件编写单元测试以确保它们正常工作。
*   **使用测试框架：** 使用 Jest 或 Mocha 等测试框架。
*   **模拟依赖项：** 模拟外部依赖项以在测试期间隔离组件。
*   **测试边缘情况：** 测试边缘情况和错误条件以确保组件的健壮性。
*   **使用 React Testing Library：** 优先使用 React Testing Library 进行组件测试，因为它鼓励从用户角度进行测试，促进更好的可访问性和更健壮的测试。

### 集成测试

*   **测试组件之间的交互：** 编写集成测试以确保组件正确协作。
*   **测试 API 调用：** 测试 API 调用以确保数据被正确获取和保存。
*   **使用测试框架：** 使用 Jest 或 Mocha 等测试框架以及 `msw`（Mock Service Worker）等库来拦截和模拟 API 调用。

### 端到端测试

*   **测试整个应用程序：** 编写端到端测试以确保整个应用程序正常工作。
*   **使用测试框架：** 使用 Cypress 或 Playwright 等测试框架。
*   **测试用户流程：** 测试常见用户流程以确保应用程序提供良好的用户体验。
*   **专注于关键路径：** 优先为关键用户流程编写端到端测试以确保应用程序稳定性。

### 测试组织

*   **与组件共置测试：** 将测试保存在与它们测试的组件相同的目录中。
*   **使用一致的命名约定：** 对测试文件使用一致的命名约定（例如，`ComponentName.test.js`）。
*   **按功能组织测试：** 按功能组织测试以提高可维护性。

### 模拟和存根

*   **模拟外部依赖项：** 模拟外部依赖项以在测试期间隔离组件。
*   **存根 API 调用：** 存根 API 调用以防止测试期间的网络请求。
*   **使用模拟库：** 使用 Jest 的内置模拟功能或 `msw` 等模拟库。

## 6. 常见陷阱和注意事项

### 常见错误

*   **不理解服务器端渲染：** 未能有效利用 SSR 可能影响 SEO 和初始加载性能。
*   **过度复杂化状态管理：** 对简单状态管理需求使用 Redux 可能增加不必要的复杂性。
*   **不优化图像：** 不使用 `next/image` 可能导致图像大小过大和加载时间缓慢。
*   **忽略安全最佳实践：** 忽视安全可能导致漏洞。
*   **不彻底测试应用程序：** 测试不足可能导致错误和回归。
*   **意外在客户端代码中暴露 API 密钥或机密。**

### 边缘情况

*   **优雅处理错误：** 实施适当的错误处理以防止应用程序崩溃。
*   **处理不同屏幕尺寸：** 确保应用程序响应式并在不同屏幕尺寸上正常工作。
*   **支持不同浏览器：** 在不同浏览器中测试应用程序以确保兼容性。
*   **管理复杂数据结构：** 使用适当的数据结构和算法高效管理复杂数据。

### 版本特定问题

*   **破坏性变更：** 在升级 Next.js 版本时注意破坏性变更。
*   **已弃用的功能：** 避免使用已弃用的功能。
*   **与第三方库的兼容性：** 确保第三方库与正在使用的 Next.js 版本兼容。

### 兼容性问题

*   **浏览器兼容性：** 确保应用程序与目标浏览器兼容。
*   **第三方库兼容性：** 确保第三方库与 Next.js 兼容。

### 调试策略

*   **使用浏览器开发者工具：** 使用浏览器开发者工具检查 DOM、调试 JavaScript 和分析网络请求。
*   **使用 console.log 语句：** 使用 `console.log` 语句调试代码。
*   **使用调试器：** 使用调试器逐步执行代码并检查变量。
*   **使用错误日志记录：** 将错误记录到中央服务以跟踪和分析问题。

## 7. 工具和环境

### 推荐的开发工具

*   **VS Code：** 对 JavaScript、TypeScript 和 React 有出色支持的代码编辑器。
*   **ESLint：** 用于识别和修复代码样式问题的代码检查器。
*   **Prettier：** 用于自动格式化代码的代码格式化器。
*   **Chrome 开发者工具：** 用于调试和性能分析的浏览器开发者工具。
*   **React 开发者工具：** 用于检查 React 组件的浏览器扩展。
*   **Webpack Bundle Analyzer：** 用于分析 Webpack 包大小的工具。

### 构建配置

*   **使用环境变量：** 将配置值存储在环境变量中。
*   **使用构建脚本：** 使用构建脚本自动化构建过程。
*   **优化构建设置：** 为生产优化构建设置（例如，启用压缩、树摇）。

### 代码检查和格式化

*   **使用带有推荐规则的 ESLint：** 为 JavaScript 和 React 配置带有推荐规则集的 ESLint。
*   **使用 Prettier 进行自动格式化：** 配置 Prettier 在保存时自动格式化代码。
*   **将代码检查和格式化集成到构建过程中：** 将代码检查和格式化集成到构建过程中以确保代码始终一致。
*   **使用共享配置：** 确保所有开发人员使用相同的代码检查和格式化配置。

### 部署

*   **使用 Vercel 进行简单部署：** Vercel 是部署 Next.js 应用程序的推荐平台。
*   **使用 CDN 提供静态资源：** 使用 CDN 从地理位置接近用户的位置提供静态资源。
*   **配置缓存：** 配置缓存以提高性能并减少服务器负载。
*   **监控应用程序健康状况：** 监控应用程序健康状况以快速检测和解决问题。

### CI/CD 集成

*   **使用 CI/CD 管道：** 使用 CI/CD 管道自动化构建、测试和部署过程。
*   **在 CI/CD 管道中运行测试：** 在 CI/CD 管道中运行测试以确保代码在部署前正常工作。
*   **自动化部署：** 自动化部署以减少人为错误的风险。
