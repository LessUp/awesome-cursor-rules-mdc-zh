---
description: Python 开发的综合指南，涵盖代码组织、性能、安全、测试等方面。这些规则促进可维护、高效和安全的 Python 代码库。
globs: "*.py"
---
# Python 最佳实践和编码标准

本文档概述了 Python 开发的综合最佳实践和编码标准，旨在促进清洁、高效、可维护和安全的代码。

## 1. 代码组织和结构

### 1.1. 目录结构最佳实践

*   **扁平优于嵌套（但并非总是如此）。** 从简单结构开始，根据需要重构。
*   **包 vs. 模块：** 使用包（带有 `__init__.py` 的目录）对模块进行逻辑分组。
*   **src 布局：** 考虑使用 `src` 目录将应用程序代码与项目级文件（setup.py、requirements.txt 等）分离。这有助于避免导入冲突并明确项目边界。
*   **典型项目结构：**


    project_name/
    ├── src/
    │   ├── package_name/
    │   │   ├── __init__.py
    │   │   ├── module1.py
    │   │   ├── module2.py
    │   ├── main.py  # 入口点
    ├── tests/
    │   ├── __init__.py
    │   ├── test_module1.py
    │   ├── test_module2.py
    ├── docs/
    │   ├── conf.py
    │   ├── index.rst
    ├── .gitignore
    ├── pyproject.toml or setup.py
    ├── README.md
    ├── requirements.txt or requirements-dev.txt


### 1.2. 文件命名约定

*   **模块：** 小写，使用下划线提高可读性（例如，`my_module.py`）。
*   **包：** 小写（例如，`my_package`）。除非必要，避免使用下划线。
*   **测试：** 以 `test_` 开头（例如，`test_my_module.py`）。

### 1.3. 模块组织最佳实践

*   **单一职责原则：** 每个模块应该有明确定义的目的。
*   **导入：**
    *   顺序：标准库、第三方、本地。
    *   通常首选绝对导入（例如，`from my_package.module1 import function1`）。
    *   在处理复杂包布局时，当绝对导入过于冗长或不实用时，使用显式相对导入（`from . import sibling_module`）。
*   **常量：** 在模块级别定义大写常量（例如，`MAX_ITERATIONS = 100`）。
*   **Dunder 名称：** `__all__`、`__version__` 等应该在模块文档字符串之后但在任何导入之前（除了 `from __future__`）。使用 `__all__` 明确定义公共 API。

### 1.4. 组件架构建议

*   **分层架构：** 适用于大型应用程序，将关注点分离为表示层、业务逻辑层和数据访问层。
*   **微服务：** 对于非常大的应用程序，考虑将系统分解为更小的独立服务。
*   **六边形/清洁架构：** 强调将业务逻辑与数据库和框架等外部依赖解耦。
*   **依赖注入：** 使用依赖注入来提高可测试性并减少耦合。

### 1.5. 代码分割策略

*   **按功能：** 根据不同功能将代码分割为模块（例如，用户管理、数据处理）。
*   **按层：** 分离表示、业务逻辑和数据访问代码。
*   **延迟加载：** 使用 `importlib.import_module()` 按需加载模块，提高启动时间。
*   **条件导入：** 仅在需要时根据特定条件导入模块。

## 2. 常见模式和反模式

### 2.1. 设计模式

*   **单例：** 限制类的实例化为一个对象。
*   **工厂：** 创建对象而不指定要创建的确切类。
*   **观察者：** 定义对象之间的一对多依赖关系，以便当一个对象改变状态时，所有依赖者都会收到通知。
*   **策略：** 定义一系列算法，封装每一个，并使它们可互换。
*   **装饰器：** 动态地为对象添加职责。
*   **上下文管理器：** 保证资源得到适当清理（例如，文件被关闭）。

### 2.2. 常见任务的推荐方法

*   **数据验证：** 使用 `pydantic` 或 `marshmallow` 等库进行数据验证和序列化。
*   **配置管理：** 使用 `python-decouple`、`dynaconf` 或标准库的 `configparser` 等库来管理环境特定设置。
*   **日志记录：** 使用 `logging` 模块进行结构化日志记录。适当配置日志级别和处理程序。
*   **命令行界面：** 使用 `argparse`、`click` 或 `typer` 创建命令行界面。
*   **异步编程：** 使用 `asyncio` 处理 I/O 绑定和并发问题。

### 2.3. 反模式和代码异味

*   **上帝类：** 做太多事情的类。将其分解为更小、更专注的类。
*   **散弹手术：** 同时对许多不同类进行小改动。表明内聚性差。
*   **意大利面条代码：** 非结构化且难以理解的代码。使用定义良好的函数和类进行重构。
*   **重复代码：** 将通用代码提取到可重用的函数或类中（DRY - 不要重复自己）。
*   **魔法数字/字符串：** 使用命名常量而不是硬编码值。
*   **嵌套回调：** 避免过度嵌套回调。使用 `async/await` 或 promises 提高可读性。
*   **过早优化：** 在识别瓶颈之前不要优化代码。

### 2.4. 状态管理最佳实践

*   **无状态函数：** 尽可能首选无状态函数。
*   **不可变数据：** 使用不可变数据结构防止意外修改。
*   **显式状态：** 使用类或数据结构显式管理状态。避免依赖全局变量。
*   **上下文变量：** 使用 `contextvars`（Python 3.7+）在异步应用程序中管理请求范围的状态。
*   **类 Redux 模式：** 考虑使用类 Redux 模式来管理客户端和复杂应用程序状态。

### 2.5. 错误处理模式

*   **特定异常：** 捕获特定异常而不是广泛的 `Exception` 或 `BaseException`。
*   **`try...except...finally`：** 使用 `finally` 确保清理代码始终执行。
*   **上下文管理器：** 使用上下文管理器（`with open(...) as f:`）进行资源管理。
*   **记录错误：** 记录带有完整回溯信息的异常。
*   **抛出异常：** 抛出带有信息性错误消息的异常。
*   **自定义异常：** 为特定错误条件创建自定义异常类。
*   **避免使用异常进行控制流。** 异常应该表示异常情况。

## 3. 性能考虑

### 3.1. 优化技术

*   **性能分析：** 使用 `cProfile` 识别性能瓶颈。
*   **高效的数据结构：** 为任务选择正确的数据结构（例如，`set` 用于成员测试，`dict` 用于查找）。
*   **列表推导式和生成器：** 使用列表推导式和生成器表达式编写简洁高效的代码。
*   **NumPy 向量化：** 使用 NumPy 进行数值计算，利用向量化操作。
*   **即时编译（JIT）：** 考虑使用 Numba 等 JIT 编译器处理性能关键代码。
*   **缓存：** 使用 `functools.lru_cache` 或 Redis、Memcached 等外部缓存库实现缓存机制。
*   **字符串连接：** 使用 `''.join(iterable)` 进行高效的字符串连接。
*   **避免全局变量：** 访问局部变量比访问全局变量更快。
*   **Cython：** 使用 Cython 为 Python 编写 C 扩展，提高性能。

### 3.2. 内存管理考虑

*   **垃圾收集：** 了解 Python 的垃圾收集机制。
*   **对象引用：** 注意对象引用和循环依赖，这可能阻止垃圾收集。
*   **内存分析：** 使用 `memory_profiler` 识别内存泄漏。
*   **插槽：** 在类中使用 `__slots__` 减少内存占用（禁用 `__dict__`）。
*   **生成器：** 使用生成器处理大型数据集而不将其加载到内存中。
*   **数据类型大小：** 使用最高效的数据类型来减少内存使用。

### 3.3. 渲染优化

*   对于核心 Python 库不适用。与 GUI 框架（例如，Tkinter、PyQt、Kivy）相关。
*   对于使用 Django、Flask 或 Pyramid 等框架的 Web 开发，使用高效的模板、缓存和数据库查询优化。

### 3.4. 包大小优化

*   对于核心 Python 库不适用。与 Web 应用程序或创建可执行包时相关。
*   使用 `PyInstaller` 或 `cx_Freeze` 等工具创建可执行包。
*   最小化依赖项以减少包大小。
*   使用代码压缩技术。

### 3.5. 延迟加载策略

*   **模块加载：** 使用 `importlib.import_module()` 按需加载模块。
*   **数据加载：** 仅在需要时加载大型数据集。
*   **延迟执行：** 使用生成器或协程延迟代码执行。

## 4. 安全最佳实践

### 4.1. 常见漏洞和预防

*   **SQL 注入：** 使用参数化查询或 ORM 防止 SQL 注入攻击。
*   **跨站脚本（XSS）：** 清理用户输入并转义输出以防止 XSS 攻击。
*   **跨站请求伪造（CSRF）：** 使用 CSRF 令牌防止 CSRF 攻击。
*   **命令注入：** 避免基于用户输入执行任意命令。如有必要，请仔细清理输入。
*   **路径遍历：** 验证文件路径以防止路径遍历攻击。
*   **拒绝服务（DoS）：** 实施速率限制和输入验证以防止 DoS 攻击。
*   **Pickle 反序列化：** 避免使用 `pickle` 反序列化不受信任的数据，因为它可能导致任意代码执行。使用 JSON 或 Protocol Buffers 等更安全的替代方案。
*   **依赖项漏洞：** 定期审计和更新依赖项以解决安全漏洞。
*   **硬编码机密：** 永远不要在代码中硬编码机密（密码、API 密钥）。使用环境变量或安全配置文件。

### 4.2. 输入验证最佳实践

*   **白名单：** 根据允许值的白名单验证输入。
*   **正则表达式：** 使用正则表达式验证输入格式。
*   **数据类型验证：** 确保输入数据类型正确。
*   **长度验证：** 限制输入字符串的长度。
*   **清理：** 从输入中删除或转义潜在有害字符。
*   **使用库：** 使用 `cerberus` 和 `schematics` 等库协助验证输入。

### 4.3. 身份验证和授权模式

*   **身份验证：**
    *   使用强密码哈希算法（例如，bcrypt、Argon2）。
    *   实施多因素身份验证（MFA）。
    *   使用安全的会话管理技术。
    *   考虑使用专用身份验证服务（例如，Auth0、Okta）。
*   **授权：**
    *   实施基于角色的访问控制（RBAC）或基于属性的访问控制（ABAC）。
    *   使用权限系统控制对资源的访问。
    *   执行最小权限原则。
    *   使用访问令牌（JWT）。

### 4.4. 数据保护策略

*   **加密：** 对静态和传输中的敏感数据进行加密。
*   **数据掩码：** 在向用户显示敏感数据时进行掩码处理。
*   **令牌化：** 用非敏感令牌替换敏感数据。
*   **数据丢失防护（DLP）：** 实施 DLP 措施防止敏感数据离开组织。
*   **定期备份和灾难恢复计划。**

### 4.5. 安全 API 通信

*   **HTTPS：** 始终使用 HTTPS 进行 API 通信。
*   **API 密钥：** 使用 API 密钥进行身份验证。
*   **OAuth 2.0：** 使用 OAuth 2.0 进行委托授权。
*   **输入验证：** 在处理之前验证所有 API 请求。
*   **速率限制：** 实施速率限制防止滥用。
*   **Web 应用程序防火墙（WAF）：** 实施 WAF 提供集中安全层。

## 5. 测试方法

### 5.1. 单元测试策略

*   **测试单个单元：** 独立测试单个函数、类或模块。
*   **测试驱动开发（TDD）：** 在编写代码之前编写测试。
*   **覆盖率：** 争取高测试覆盖率。
*   **断言样式：** 使用适当的断言方法（例如，`assertEqual`、`assertTrue`、`assertRaises`）。
*   **边界条件：** 测试边界条件和边缘情况。
*   **错误条件：** 测试在适当时抛出异常。

### 5.2. 集成测试方法

*   **测试交互：** 测试不同模块或组件之间的交互。
*   **数据库测试：** 测试数据库交互。
*   **API 测试：** 测试 API 端点。
*   **模拟外部服务：** 在集成测试期间使用模拟来模拟外部服务。
*   **专注于关键工作流。** 集成测试应该执行最重要的用户工作流。

### 5.3. 端到端测试建议

*   **测试整个系统：** 从端到端测试整个系统。
*   **用户视角：** 从用户的角度编写测试。
*   **浏览器自动化：** 使用 Selenium 或 Playwright 等浏览器自动化工具。
*   **真实世界场景：** 在端到端测试中模拟真实世界场景。
*   **专注于关键路径。** 端到端测试编写和维护成本高，因此专注于最关键的路径。

### 5.4. 测试组织最佳实践

*   **单独的测试目录：** 将测试保存在单独的 `tests` 目录中。
*   **镜像源结构：** 在测试目录中镜像源代码结构。
*   **测试模块：** 为每个源模块创建测试模块。
*   **测试类：** 使用测试类对相关测试进行分组。
*   **使用测试运行器：** 使用 `pytest` 或 `unittest` 测试运行器。
*   **使用夹具：** 利用夹具为测试设置和拆除资源。

### 5.5. 模拟和存根技术

*   **`unittest.mock`：** 使用 `unittest.mock` 模块进行模拟和存根。
*   **补丁：** 使用 `patch` 在测试期间用模拟替换对象。
*   **副作用：** 为模拟定义副作用以模拟不同场景。
*   **模拟外部依赖：** 模拟数据库、API 和文件系统等外部依赖。
*   **使用依赖注入提高可测试性。** 依赖注入使模拟依赖更容易。

## 6. 常见陷阱和注意事项

### 6.1. 常见错误

*   **可变默认参数：** 避免在函数定义中使用可变默认参数。
*   **变量作用域：** 注意嵌套函数中的变量作用域。
*   **`==` vs. `is`：** 使用 `==` 进行值比较，使用 `is` 进行对象身份比较。
*   **`try...except` 块：** 在 try 块中放置太多代码。尽量保持 try 块尽可能小。
*   **忽略异常：** 在不处理或记录异常的情况下吞没异常。
*   **不正确的缩进。** 缩进错误是错误的常见来源。
*   **不使用虚拟环境。** 不使用虚拟环境可能导致依赖冲突。

### 6.2. 边缘情况

*   **浮点运算：** 注意浮点运算的限制。
*   **Unicode 处理：** 仔细处理 Unicode 字符串。
*   **文件编码：** 在读写文件时指定文件编码。
*   **时区：** 正确处理时区。
*   **资源限制：** 注意并处理系统资源限制（例如，文件句柄、内存）。

### 6.3. 版本特定问题

*   **Python 2 vs. Python 3：** 注意 Python 2 和 Python 3 之间的差异。
*   **语法变化：** 注意不同 Python 版本中的语法变化。
*   **库兼容性：** 确保库与正在使用的 Python 版本兼容。
*   **已弃用的功能。** 避免使用已弃用的功能。

### 6.4. 兼容性问题

*   **操作系统：** 在不同操作系统（Windows、macOS、Linux）上测试代码。
*   **Python 实现：** 考虑与不同 Python 实现（CPython、PyPy、Jython）的兼容性。
*   **数据库版本：** 确保与不同数据库版本的兼容性。
*   **外部库：** 注意外部库的兼容性问题。

### 6.5. 调试策略

*   **`pdb`：** 使用 `pdb` 调试器进行交互式调试。
*   **日志记录：** 使用日志记录跟踪程序执行。
*   **打印语句：** 使用打印语句进行简单调试。
*   **断言：** 使用断言检查预期条件。
*   **性能分析：** 使用分析器识别性能瓶颈。
*   **代码分析工具：** 使用 pylint 或 flake8 等代码分析工具检测潜在问题。
*   **远程调试：** 在调试运行在远程服务器上的代码时使用远程调试工具。

## 7. 工具和环境

### 7.1. 推荐的开发工具

*   **IDE：** PyCharm、VS Code（带 Python 扩展）、Sublime Text。
*   **虚拟环境管理器：** `venv`（内置）、`virtualenv`、`conda`、`pipenv`。
*   **包管理器：** `pip`（默认）、`conda`、`poetry`。
*   **调试器：** `pdb`、IDE 调试器。
*   **分析器：** `cProfile`、`memory_profiler`。
*   **代码检查器：** `pylint`、`flake8`。
*   **格式化器：** `black`、`autopep8`、`YAPF`。
*   **静态分析器：** `mypy`、`pytype`。
*   **笔记本环境：** Jupyter Notebook、Jupyter Lab、Google Colab。

### 7.2. 构建配置最佳实践

*   **`pyproject.toml`：** 使用 `pyproject.toml` 进行构建配置（PEP 518、PEP 621）。
*   **`setup.py`：** 对于遗留项目使用 `setup.py`（但新项目首选 `pyproject.toml`）。
*   **依赖管理：** 在 `requirements.txt` 或 `pyproject.toml` 中指定依赖项。
*   **虚拟环境：** 使用虚拟环境隔离项目依赖项。
*   **可重现构建：** 通过固定依赖项确保可重现构建。

### 7.3. 代码检查和格式化建议

*   **PEP 8：** 遵守 PEP 8 样式指南。
*   **代码检查器：** 使用代码检查器强制执行代码样式并检测潜在问题。
*   **格式化器：** 使用格式化器根据 PEP 8 自动格式化代码。
*   **预提交钩子：** 使用预提交钩子在提交代码之前运行代码检查器和格式化器。
*   **一致的样式：** 在整个项目中保持一致的代码样式。

### 7.4. 部署最佳实践

*   **虚拟环境：** 在虚拟环境中部署应用程序。
*   **依赖管理：** 使用 `pip install -r requirements.txt` 或 `poetry install` 安装依赖项。
*   **进程管理器：** 使用 `systemd`、`Supervisor` 或 `Docker` 等进程管理器管理应用程序进程。
*   **Web 服务器：** 使用 Gunicorn 或 uWSGI 等 Web 服务器为 Web 应用程序提供服务。
*   **负载均衡：** 使用负载均衡器在多个服务器之间分配流量。
*   **容器化：** 使用 Docker 等容器化技术打包和部署应用程序。
*   **基础设施即代码（IaC）：** 使用 Terraform 或 CloudFormation 等 IaC 工具管理基础设施。

### 7.5. CI/CD 集成策略

*   **持续集成（CI）：** 在每次提交时自动构建和测试代码。
*   **持续交付（CD）：** 自动将代码部署到暂存或生产环境。
*   **CI/CD 工具：** 使用 Jenkins、GitLab CI、GitHub Actions、CircleCI 或 Travis CI 等 CI/CD 工具。
*   **自动化测试：** 在 CI/CD 管道中包含自动化测试。
*   **代码分析：** 将代码分析工具集成到 CI/CD 管道中。
*   **自动化部署。** 自动化部署过程以减少手动工作和错误。

通过遵守这些最佳实践和编码标准，开发人员可以创建更强大、可维护和安全的 Python 代码。
